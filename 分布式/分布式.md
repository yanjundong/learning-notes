# 一、初识分布式系统

## 1、定义

一个分布式系统是由多个通过网络互联的**独立自治**的计算节点组成。

这些节点之间基于**<span style="color:red">消息传递机制</span>**进行相互协作，以完成共同的目标。

从用户的角度看，分布式系统是一个整体，用户在使用系统功能的时候，是感觉不到分布式系统的内部构成和节点之间的协作关系。比如，我们在刷微博时，是感觉不到新浪服务器之间的协作，也更觉不到某一台服务器的更换，我们只感觉像是在跟一台服务器交互。

## 2、几个要点

1. 多个计算节点

   计算节点一般指单个计算机，也可以是计算机中的一个进程、线程或者后台服务。

2. 网络互联

   我们并不关心节点之间是通过有线、无线或者什么其他网络通信方式互联，我们只关心节点之间逻辑上的互联结构。

3. 独立自治

   每个节点都有自己独立的CPU、独立的时钟，发生错误的时机和模式也都是相互独立的。

4. 各个节点相互协作以完成共同的目标

5. 消息传递模型

   节点基于消息传递模型相互协作，并不是内存共享模型。

   如下面的图所示，节点之间的消息传递通常以*毫秒*计，而如果在单机中，耗时可以*纳秒*计，所以在设计分布式系统时，应该**<span style="color:red">尽可能的减少节点之间的通信</span>**，此时通信复杂度是影响系统效率的重要因素。

   分布式系统在设计时，必须要应对局部失效、消息延迟/丢失等错误。

   ![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200318-204907.png)

   ![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200318-205339.png)

> 虚拟内存管理的作用：
>
> - 扩大物理内存，在内存不够时，通过这种方法，让用户感觉到内存很大；
> - 给每个进程提供一个独立的内存地址空间。



# 二、分布式概述

## 1、背景

为什么会出现分布式系统？

- 大大小小的计算机设备无处不在

- 网络通信技术高速发展，网络的规模不断扩大

- 摩尔定律走到了瓶颈，免费的午餐已经结束

- 越来越多的计算任务需要交由分布在不同区域的计算节点来协作完成

  比如，我们在支付宝上购买电，就涉及到阿里的服务器、国家电网的服务器，如果你的钱在银行的话，还涉及到银行的服务器。因此购电的这个任务就需要这多个服务器来协作共同完成。

## 2、构建分布式系统的目的

- 提高计算能力——用多台计算机同时执行任务
- 提高存储能力——一台计算机能够挂载的硬盘是有限的，可以使用多台计算机
- 提高网络吞吐能力（并发访问能力）——一台计算机的网络请求是有限的
- 提高可靠性（解决局部失效问题）——主备节点，防止局部失效
- 提高安全性（解决局部攻击问题）
- 提高可扩展性（解决瓶颈问题）
- 实现资源共享
- 实现跨越时空的协同服务（发挥不同节点的优势）

## 3、衡量分布式系统优劣的特性

- 可扩展性/可伸缩性（Scalability）
  - 垂直可扩展性（Vertical Scalability）——把一个单核CPU电脑上的程序复制到一个多核CPU电脑上后，程序的执行效率也会随之提高
  - 水平可扩展性（Horizontal Scalability）——程序的执行效率能够随着系统节点的增加而增加

- 容错性（Fault Tolerance/Reliability）
  - 可用性（Availability）——某些节点失效时，系统还能否用
  - 可恢复行（Recoverability）——在节点重启之后，就可以继续使用

- 透明性（Transparency）——用户感觉不到分布式系统的构造

- 开放性（Openness）——
- 安全性（Security）——能够防止外部/内部攻击
- 可维护性（Maintainability）——后台管理员能很方便的管理某个节点

## 4、设计挑战例子：数据库备份

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200319-091354.png)

上面的这种***一主多备***的模式，我们规定当客户端要写数据时，只能往主节点上写，然后主节点把数据更新的消息传送给其他备份节点，这样也就保持了各个节点的**数据一致性**。这种一致性带来的好处就是客户端**可以从任意的节点读取数据**，而在现实中读的数据访问量也远远大于写的访问量，就像浏览微博时，大部分的时间你都是在看别人的动态，很少发送动态。

采用一主多备模式带来的好处是：

- 提高了可靠性——在主节点失效后，自动地切换某一个备份节点作为主节点（这里就要求分布式系统各节点的一致性）
- 提高了性能——就像上面说的，客户端可以从任意的节点上读取数据。

上面说的，感觉“一主多备”十分的完美，但这样的模式也还有很多的问题解决，其中一个就是**容错性**问题。例如，客户端请求更新磁盘上的`x=2`，这时主节点就开始往其他备份节点上发送消息，但给备份节点2的消息丢失了，如果系统不处理这样的问题，就破坏了分布式的一致性。如果想到了用消息确认的方式，那样就会造成通信复杂度增高。

那怎么在高效的情况下实现分布式一致性呢？可以使用`Paxos协议`、`Raft协议`。

## 5、分布式的一致性

分布式的一致性分为：

- 严格一致性
- 强一致性
  - 顺序一致性
  - 线性一致性
- 弱一致性——像微博下的评论，过五分钟更新也是可以的，但是像银行的交易就必须实现强一致性，我现在交易了以后，马上就要看到金额的变化。
- 最终一致性

## 6、分布式系统的例子

- 实现资源共享的分布式系统（分布式存储）
  - Web系统、DNS系统
  - 网络文件系统：NFS、HDFS
  - P2P资源共享系统：BitTorrent、UTorrent
  - 区块链、比特币
- 高性能计算系统：**Map-Reduce**、**Spark**、TensorFlow
- 云计算
- 网格计算
- 集群计算
- 分布式信息系统：**跨企业**应用系统、金融应用系统



# 三、分布式节点之间的通信技术

底层通信技术

- 基于TCP的点对点通信技术
- 基于UDP的点对点通信技术

并发服务技术

上层通信技术

- 远程过程调用RPC/远程方法调用RMI
- 基于消息队列的通信技术
- 

## 1、远程过程调用RPC

- **<span style="color:red">远程过程调用（Remote Rrocedure Call，RPC）</span>**：使应用程序可以像调用本地节点上的**<span style="color:red">过程（子过程）</span>**那样去调用一个远程节点上的子程序。

- 对于调用者来说不能区分调用者来自本地还是远程

- RPC将面向过程的通用编程模型扩展到了分布式环境

- 实现了跨进程、跨语言、跨网络、跨平台的过程调用

- 强化了面向接口编程的编程风格

  A、B计算机规定好调用的接口，就像在Java中，`List` 只是接口，`ArrayList` 、`LinkedList`是其实现类。调用者并不用关系内部是怎么实现的，就需要知道接口的名字就可以直接调用。

- 实现RPC必须要有RPC中间件的支持



RPC一般采用**同步**调用方式，也就是说调用者在调用远程服务时，需要等待远程的服务执行完，才能继续执行。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200319-140302.png)

## 2、远程方法调用RMI

- **<span style="color:red">远程方法调用（Remote Method Invocation，RMI）</span>**：将面向对象的编程模型扩展到了分布式环境。
- RMI使应用程序可以像调用本机上对象的方法一样调用远程主机中对象的方法。
- 利用RMI调用远程对象的方法时，参数可以是一个本地对象，也可以是另外一个远程对象（第三个节点）。
- 在整个系统范围内支持<span style="color:red">垃圾回收</span>。
- 实现RMI必须要有RMI中间件的支持

## 3、RPC/RMI中间件的作用

- 定义并利用Socket服务接口实现了一套调用者和被调用者之间的通信协议。例如Java RMI的Java Remote Method Protocol（JRMP）
- 实现了过程参数的<span style="color:red">序列化、反序列化</span>；过程运算结果的序列化、反序列化。序列化的目的是为了方便存储、传输，但是在以字节码的方法保存对象后，在不同的计算机上怎么过把发序列化成对象。
- 通信过程中的<span style="color:red">错误处理</span>
- 过程服务进程（或远程对象）的<span style="color:red">集中注册与发现（目录服务）</span>
- 远程对象的统一标识和生命周期管理，例如，A、B计算机上都有一个`f()`方法，那我们怎么知道调用的是哪个方法呢？
- 在服务端支持并发访问。（多采用多线程技术），当A、B计算机同时调用C计算机上的`f()`方法时，应该要有两个线程去执行这个方法。

### 3.1 接口定义语言IDL

对于<span style="color:red">支持跨编程语言调用</span>的RPC/RMI中间件而言，有着一套独立于任何编程语言的<span style="color:red">接口定义语言IDL</span>。

为了将IDL转化为本地语言，有了一系列的工具：idl2Java（转化为 Java 语言）、idl2CPP（转化为 C++ 语言）等。

根据IDL生成stub和skeleton的工具。

```idl
//CORBA IDL example
struct Person {
	string name;
	string place;
	long year;
}
interface PersonList {
	readonly attribute string listname;
	void addPerson(in Person p);
	void getPerson(in string name, out Person p);
	long number();
}
```

远程过程调用的流程：

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200325-122747.png)

### 3.2 常用的 RPC/RMI 中间件

- Java RMI：Java的自娱自乐
- Microsoft .NET Remoting：.Net的自娱自乐
- CORBA：重量级分布式对象中间件，跨语言
- gRPC：Google的RPC中间件，高效、开源、跨语言
- Thrift：Facebook、Apache的RPC中间件，高效、开源、跨语言
- Hessian：基于HTTP+二进制，跨语言
- Dubbo：淘宝开源中间件，Java
- Motan：新浪开源中间件，Java

> Google Protocol Buffers：一种对象序列化标准和开发库。



## 4、Web Service技术

### 4.1 什么是Web Service？

1. 为了方便网络上不同节点之间互操作而定义的一套协议标准，也可视为<span style="color:red">实现远程过程调用</span>的一套协议标准。

2. 以 HTTP 作为传输层协议实现 RPC 的一套协议标准。

   为什么以 HTTP 作为传输层协议？

   - 因为防火墙会对 HTTP 的80端口放行。
   - HTTP 的基础设施较全。

3. 方便了 Business to Business 的业务集成。可以将多个第三方服务组织合成一种新的服务。

4. Web系统也不再只是共享文档，也被用于节点之间的互操作。

5. 客服端——服务器模式

6. 跨平台、跨语言、面向接口编程

7. 实现面向服务构架（SOA：Service-oriented Architecture）的重要技术之一。

   > 面向服务架构 很类似于面向接口编程——我不管你内部是怎么实现的，只需要定义好接口给我调用就可以了。而面向服务架构就是 暴露出服务。比如说下面的旅行代理服务，客户不管你是怎么订票的、怎么订酒店的。
   >
   > ![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200325-131233.png)



### 4.2 Web Service主要包含哪些标准协议？

1. 消息编码标准（XML）

2. 传输协议标准（HTTP\SMTP\TCP\UDP）——>更多的是使用HTTP

3. 远程对象访问协议（即远程方法调用协议）：SOAP（Simple Object Access Protocol）

4. **Web 服务描述语言：WSDL**（Web Services Description Language） （主要描述服务接口定义）

   类似于上面的 IDL

5. **服务目录、服务注册、服务发现：UDDI**(Universal Discovery Description and Integration)

6. 安全相关标准：签名、加密、认证等

7. 服务组合、服务编排

## 5、仅支持点对点通信的缺点

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200330-095101.png)

- 在复杂分布式系统中，仅支持点对点通信会使不同节点之间的通信关系十分复杂（如上图：一个生产者必须得建立3个 socket 和3个消费者建立连接），耦合度高。
- 数据生产节点需要记录多个消费节点的标识，消费节点需要记录多个生产节点的标识。（如果现在消费者中加入了一个 “异常分析” 节点，那么3个生产者的节点都需要记录这个节点的标识）
- 可扩展性差：每增加一个生产者或者消费者会对多个节点产生影响。
- 容错性差：节点失效后，会丢失数据；生产者、消费者速度不匹配时也会丢失数据（这种速度不匹配只是暂时上的不匹配）。

### 5.1 解决方案——增加中介节点

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200330-100007.png)



- 降低了耦合度：所有的生产者只会向 “中介节点” 发送数据；所有的消费者也只会从 “中介节点” 订阅自己需要的数据。
- 提高了容错性：中介节点具有数据缓存功能，部分节点失效、或者通信双方速度暂时不匹配时数据也不会丢失。

- 提高了可扩展性：增加消费节点对生成节点无影响；增加同类型的生成节点，对消费节点无影响。（在消费节点中增加 “异常处理” 节点后，该节点只需要自己去订阅自己需要的数据，并不会影响其它节点）（增加生产者节点也是同理）。

- 需要注意，“中介节点” 本身也是分布式的，所有不用担心中介节点失效的问题。

## 6、基于消息中间件的通信技术

- <span style="color:red">面向消息中间件（MOM：Message Oriented Middleware）</span>提供了一种分布式消息队列服务，使得节点之间可以实现基于消息的形式灵活的<span style="color:red">异步通信</span>。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200330-101419.png)

> 上面的异步通信是指：
>
> 1. 发送方可以在任何时刻发出消息，不必等待接收方上线，更不用等消息发送成功后再做下一步工作。
> 2. 接收方不必以阻塞方法等待消息的到来。

## 7、分布式系统的总线型架构

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200330-101654.png)

- 不同节点之间通过<span style="color:red">虚拟总线</span>相连。
- 消息发送方不必知道接收方是谁，接收方也不必知道发送方是谁。
- 发送者和接受者之间用<span style="color:red">异步方法</span>通信。
- 一种松耦合的架构。
- 不同节点完成不同的功能，分工协作

## 8、MOM 支持的两种通信技术

- 消息队列通信模式：
  - 在生产者和消费者之间建立的满足先进先出的<span style="color:red">消息队列</span>
  - ==消息队列的消息一旦被某个消费者取走，该消息就会从该队列中删除==。
  - 消息的出队按照某种 <span style="color:red">负载均衡</span>策略发送给特定的消费者。
  - 高级队列模式：带优先级的队列；支持持久性的队列（可以持久化到硬盘）。
- 主题/订阅通信模式：
  - 支持向一个特定的<span style="color:red">消息主题</span>发布消息。
  - ==多个订阅同一主题的消费者可以同时接收发到该消息主题的消息==。
  - 可以灵活实现广播/组播等多对多通信模式。

上面两者的本质区别在于 黄底 标识的部分。

## 9、常用的MOM中间件

**ActiveMQ**

- 由 Apache 出品，完全兼容 JMS（Java Message Service）——JAVA消息服务，是一种标准的API接口，类似于 `Map`接口，不同的消息中间件就是 `HashMap` 或者 `EnumMap`；
- 为多种编程语言提供客户端API；
- 与生产者、消费者客户端之间采用 AMQP（Adcanced Message Queuing Protocol）标准化协议进行通信；
- 必须部署`中心服务器`作为`消息路由代理`。中心服务器可由`服务器集群`代替。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200406-162241.png)

## 10、JMS和AMQP

消息服务的常见规范有以下两种：

JMS（Java Message Service）——JAVA消息服务：

- 基于JVM消息代理的规范。`ActiveMQ`、`HornetMQ`是JVM的实现。

AMQP（Adcanced Message Queuing Protocol）

- 高级消息队列协议，也是一个消息代理的规范，兼容JMS
- `RabbitMQ`是AMQP的实现。

二者的区别如下：

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200406-171555.png)

# 四、分布式存储

## 1、 复制方法分类

### 1.1 单主复制：

- 一个领导者多个追随者
- 优点：实现相对简单。大多数应用场景都是读多写少。
- 缺点：主库即是性能瓶颈，又是 `单点故障节点（Single point of failure）`
- 为提高容错性，自动将某个从库切换到主库时会面 `临脑裂问题`

### 1.2 多主复制：

- 系统中有多个主库接受写入操作。每个主库都将该数据更改转发给所有其他节点。每个领导者同时扮演其他领导者的追随者。
- 应用场景：多数据中心之间的复制；协同文档编辑。
- 优点：写入性能高。
- 缺点：写入冲突问题、多副本一致性问题解决方法太复杂。

### 1.3 无主复制：

- 没有主库从库的概念。
- 客户端直接将写入请求发送到各个副本；或者客户端将写入发送给某个节点，由该节点充当代理节点向其他节点转发写入请求。

## 2、同步复制和异步复制

` 同步复制` 和 `异步复制` 这两种复制都是基于 `领导者复制`。

### 2.1 同步复制

- 领导者写入自己的存储器，并且接受到所有跟随者已经成功更新本地存的应答后再向用户返回成功写入应答。
- 优点：副本之间的一致性好；（`强一致性`）
- 缺点：写入速度慢；一个节点失效会使整体写入功能失败。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200430-105554.png)

### 2.2 异步复制

- 领导者自己写入成功后立即向用户返回成功应答，不等待其它跟随者的应答消息。
- 优点：写入速度快；容错性好；
- 缺点：保持多副本一致性复杂；（引入`最终一致性`概念）

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200430-114410.png)

### 2.3 混合复制

 与部分跟随者节点之间采用同步复制，另外的跟随者节点之间采用异步复制。

与响应速度快的节点（例如，距离更近的节点）采用同步复制，与远距离的节点（例如，为了避免地震、海啸等灾害建立的节点）之间采用异步复制。

### 2.4 总结

同步复制能够实现 `强一致性`，在某些特定系统中，如银行系统，需要实现。

大部分的系统只需要达到 `最终一致性` 即可，例如微博、区块链等。

## 3、更新日志

 ### 3.1 更新日志

数据副本节点一般分两步处理数据写入（或复制）请求：先将更新操作信息`追加`到 `更新日志`；再根据操作参数更新`本地存储系统`（或称为`本地状态机`）

### 3.2 在传统数据库中的用途

- 更新 `本地存储系统` 失败后，还可以根据日志重试失败的更新操作。（例如计算机本身Fail-Stop-Recover了）
- 更新失败后也便于 `本地存储系统` 恢复到之前的一致性状态。
- 保存了整个更新历史，便于出现错误时进行问题回溯。
- 某些设计中，写入请求成功追加到日志就可以应答用户。这样只在日志文件尾部追加，提高了写入速度。

### 3.3 在分布式存储中的新用途

- 便于落后的追随者追赶上领导者的最新状态。
- 便于实现分布式事务。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200430-131641.png)

- 如果能将 Leader 的更新日志复制给各个 Follower，那么就可以保证各个副本的本地存储系统是一致的（或最终一致的）
- 复制状态机（Replicated state machines）的思想

## 4、快照

- 长时间运行后，更新日志会变得过于冗长，并且占用很多非易失存储器的存储空间。
- 将某个时间点的本地存储系统完整的保存在非易失存储器中，形成系统的一个快照。
- 快照对应时间点之前的更新日志就可以删除了。

### 4.1 基于快照和日志进行状态追赶

- 如果一个追随者的状态落后了很多，在追赶领导者时可以先把一个快照完整地复制到自己的本地存储系统，然后再根据快照点之后的更新日志追赶至最新状态。

## 5、数据分区的基本方法（一）

### 5.1 合理数据分区的目标

- 将数据和查询负载 `均匀分布` 在各个节点上，避免出现 `偏斜` (skew) 和 `热点` (hot spot) 问题。
- 分区方法要兼顾跨区查询问题。

### 5.2 根据主键范围进行分区

## 6、数据分区的基本方法（二）

### 6.1 根据主键的哈希值进行分区

- 将整个哈希空间均匀分成 k 个区间，每个存储节点负责一个 `哈希区间`。
- 计算新插入数据元素主键的哈希值，然后计算该哈希值落入了哪个哈希区间，最后将该数据元素分配给该哈希区间对应的存储节点。
- 在增加或删除物理节点时会产生数据移动，例如下面的系统中增加了一个节点，现在成了5个节点。就不再是 `hash mode 4`了。相应的存放位置也要发生变化。

  ![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200430-135653.png)

### 6.2 优点

- 可以在一定程度上避免 `偏斜` 和 `热点问题`
- 无须全局索引，因而也无须中心节点。

### 6.3 缺点

- 基于主键进行连续范围查询效率极低。
- 在物理存储节点较少时仍会出现偏斜和热点问题。（可以采用虚拟节点的方法进行缓解）
- 在物理节点数量发生变化时，会导致大量数据的迁移。

### 6.4 基于一致性哈希算法的分区

`Distributed Hash Table`（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。

<h4>基本原理</h4>

将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200430-135751.png)

一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 node5，只需要将它前一个节点 node4 上的数据重新进行分布即可，对于节点 node1、node2、node3 都没有影响。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200511-001007.png)

<h4>虚拟节点</h4>

上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。

数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。

解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

## 7、数据分区案例：MemCached

### 7.1 什么是MemCached？

- `MemCached` 是一个开源的高性能分布式内存缓存服务器软件；
- `MemCached` 支持的是键值对（key-value）存储模型，逻辑上相当于将一个巨大的内存HashMap分布存储在多个`MemCached` 节点上。
- 常用于缓存数据库查询结果，减少数据库访问次数，提高动态Web应用的响应速度。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ20200510-235949.png)



### 7.2 分区与复制

在 Node1 中有 p1分区的主分区，但是在其他两个节点（N3/N4）中有p1分区的备份。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ截图20200609192445.png)

## 8、CAP定理

- `Consistensy`（一致性）：不同节点上数据的强一致性

- `Partition Tolerance`（割断容忍性）：允许部分节点与其他节点断裂

- `Availability`（可用性）：发出的请求在规定时间段内总能返回结果（请求响应延迟短，可用性高；否则可用性低）

- 在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

  可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

  - 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
  - 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。

> 分布式系统的节点都是在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险。这个网络断开的场景叫做 `网络分区`。

## 9、BASE

BASE 是基本可用（`Basically Available`）、软状态（`Soft State`）和最终一致性（`Eventually Consistent`）三个短语的缩写。

BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

### 9.1 基本可用

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

### 9.2 软状态

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

### 9.3 最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。

#  五、分布式文件系统

## 1. 常见的分布式文件系统

- GFS：Google File System
- HDFS：Hadoop Distributed File System
- Ceph：同时支持块存储、对象存储和文件存储
- TFS：Taobao File System
- FastDFS

## 2. HDFS 分布式文件系统

- HDFS 遵循 主/从 架构，由单个 NameNode（NN） 和多个 DataNode（DN）组成。
- 高容错：采用数据多副本方案，部分硬件的损坏不会导致全部数据的丢失。
- 高吞吐量：支持多个客户端同时与多数据节点直接通信，实现了高吞吐量的数据访问、
- 大文件支持：HDFS 适合于大文件的存储，文档的大小应该是 GB 到TB级别的
- 简单一致性模型：HDFS  更适合于 ==一次写入多次读取==（write-once-read-many）的访问模型。支持将内容追加到文件末尾，不能从文件任意位置新增数据。

> HDFS  不适合大量小文件存储。因为 HDFS 是在 NameNode 中存储了某个文件存储在哪个节点上，所有如果有大量的小文件，很快就会占满 NameNode 。
>
> 解决办法是在应用层上逻辑处理这些小文件，把一类的小文件包装为一个大文件，在访问时计算它的偏移量。

## 3. NameNode 维护的两张表

注：HDFS 中的每个数据块都有全局唯一的编号

下面这两张表平时都是在内存里的，但只有 Table1 会持久到硬盘，防止断电时丢失。Table2不需要存储到硬盘。

因此 Table1 存储了文件名和存储位置，没有丢失的话，就找不到文件了。

但数据块节点会每隔1个小时向 NameNode  报告自己拥有的数据块信息，所有不需要存储。即使断电了之后也能够恢复。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ截图20200609215653.png)

## 4. HDFS 读写数据

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ截图20200609220921.png)

## 5、Hadoop平台

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ截图20200610172930.png)



# 六、HBase

## 1、特征

- HBase 是构建在 HDFS 文件系统之上的面向列的分布式数据库管理系统。
- HBase 采用稀疏表数据模型，方便查询结构化、半结构化甚至非结构化的数据。
- HBase 避免了 HDFS 的 “一次写入”（在写入文件时只能在末尾追加） 的缺陷，支持数据的随机读写。
- 在宏观逻辑上，HBase管理了多张可以==分布存储==在多个节点上的“大表’，理论上大表中的数据行数是无限的。(随着存储服务器数目增长大表的行数也可以随之增长)
- 该表的每一行都有一个 “Row Key” ，==HBase 关于每个数据表的 RowKey 列都建立了`分布式索引`==，可以根据 RowKey，快速查询该 RowKey所对应的行；也支持通过 RowKey 的取值范围进行查询。
- 支持数据分区：HBase 中的 “大表”按 RowKey 的连续取值范围分成多个 “子表”，不同的子表由不同的服务器管理（ReginServer）
- 支持通过增加服务器进行横向扩展。
- 同一个列族的字段被聚合存储在相同的 HDFS 文件中。因此查询时访问同一个列族中的字段速度很快。

缺点：

- 不支持复杂的事务，只支持行级事务，即单行数据的读写都是原子性的；
- 不支持对RowKey以外的列建立索引
- 不支持多表连接查询

## 2、体系结构

![](https://gitee.com/yanjundong97/picBed/raw/master/images/QQ截图20200611110251.png)

`HBase`中，主节点 `HMaster` 只负责子表的分裂与合并。

在 `client` 查询操作时，不是由 `HMaster` 告诉`client` 应该去哪个`HReginServer` 查询。而是去找 `Zookeeper` 查询 `分布式索引`，有了这个分布式索引，就可以知道去找哪个`HReginServer`。

一个 大表的子表会存储在不同的 `HReginServer `中，但是一个 `HReginServer`  可能存储多个大表的子表。

# 七、MapReduce

## 1、分布式并行计算框架/平台

`分布式计算平台（框架）`和运行在平台之上的`应用层模块`相互协作完成一个完整的分布式计算任务。

### 1.1 分布式计算平台的作用

  1. 将输入数据进行分片，将每个分片交给一个计算子任务处理;
  2. 将不同的计算 子任务分发给不同的计算节点执行;
        3. 子任务分发时将考虑如下因素：
        1. 各个计算节点的当前负载;
        2. 尽量让计算子任务和对应的数据分片处于同一台物理主机。

4. 帮助实现中间计算结果的合并、中间结果在不同计算节点之间的交换(混洗）
5. 容错性：监视各个子任务的执行状态，将执行失败的子任务重新调度给其它节点执行。
6. 可扩展性：对集群中计算节点的增长或减少可以自适应

 ## 1.2 应用层模块的作用

专注于实现框架要求下和具体应用逻辑相关的子任务计算逻辑。

# 八、Spark平台和基于RDD-DAG的计算模型































