 # 一、MySQL逻辑架构

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场合中应用并发挥良好作用，主要体现在存储引擎的架构上。

插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

![image-20201102161649310](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201102161649310.png)

> 一条SQL语句的执行过程：
>
> 1. 客户端
> 2. 分析器
> 3. 优化器
> 4. 缓存
> 5. 存储引擎

# 二、存储引擎

## 1、默认使用存储引擎

![image-20201102163309634](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201102163309634.png)

![image-20201102162820864](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201102162820864.png)

## 2、InnoDB

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

## 3、MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

## 4、比较

![image-20201120101618173](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120101618173.png)

# 三、SQL语法

## 1、Join

![image-20201102165344050](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201102165344050.png)

# 五、事务

## 1、概念

ACID

1. 原子性（Atomicity）

   事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

   回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）

   数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3. 隔离性（Isolation）

   一个事务所做的修改在最终提交以前，对其它事务是不可见的。

4. 持久性（Durability）

   一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

ACID 特性的关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

![image-20201119164054954](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164054954.png)

## 2、并发一致性问题

在并发环境下，事物的隔离性很难保证，因此会出现很多并发一致性问题。

### 丢失修改

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![image-20201119164509007](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164509007.png)

### 读脏数据

读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。

![image-20201119164556628](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164556628.png)

### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。

![image-20201119164704083](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164704083.png)

### 幻影读

幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![image-20201119164757052](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164757052.png)

> 产生并发不一致性问题的主要原因是`破坏了事务的隔离性`，解决方法是通过并发控制来保证隔离性。
>
> 并发控制可以通过封锁来实现，但是如果封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 3、封锁

### 封锁粒度

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

> 锁粒度小 ---> 提高系统并发性 + 增加系统开销

### 封锁类型

#### 读写锁

- 互斥锁（X Lock），允许事务删除或更新一行数据。
- 共享锁（S Lock），允许事务读一行数据。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

![image-20201119170453480](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119170453480.png)

#### 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 `IX/IS`，IX/IS 都是表锁，用来==表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁==。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

![image-20201119172159892](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119172159892.png)

> - 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
> - 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

### 封锁协议

#### 三级封锁协议

1. 一级封锁协议

   事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

   可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

   ![image-20201119172703988](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119172703988.png)

2. 二级封锁协议

   在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

   可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

   ![image-20201119173029551](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119173029551.png)

3. 三级封锁协议

   在二级的基础上，要求读取数据 A 时必须加 S 锁，`到事务结束了才能释放 S 锁`。

   可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

   ![image-20201119173203855](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119173203855.png)

#### 两段锁协议

加锁和解锁分为两个阶段进行。

在事务并发执行时，保证所执行的任何调度的效果与没有并发执行的调度效果一样，这种调度称为 `可串行化`。

假设一个调度S含有分别属于I与J的两条连续指令 $I~i~$  与$I~j~$ 

- 如果I与J引用不同的数据项，则交换I与J不会影调度中的任何指令的结果。
- 若I与J引用相同的数据项Q，则两者的顺序是重要的。只有在I与J全部都是read指令时，两条指令的执行顺序才是无关紧要的。例如，若两者的顺序为`I = read(Q), J = write(Q)` ，则不能确定I读到的值。像这样的指令就称为 `冲突指令`。

如果调度S可以经过一系列非冲突指令交换转换为S'，称二者是 `冲突等价` 的。

### MySQL隐式与显示锁定

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```sql
SELECT ... LOCK In SHARE MODE;  --对读取的行记录加一个S锁，其他事务可以对被锁定的行加S锁，但如果加X锁，则会被阻塞。
SELECT ... FOR UPDATE;	--对读取的行记录加一个X锁，其他的事务不能对已锁定的行加任何锁。
```

## 4、隔离级别

对于某些应用，保证可串行化的那些协议只允许极小的并发度。在这种情况下，采用了较弱级别的一致性。

SQL 标准规定的隔离性级别如下：

- 可串行化（SERIALIZABLE）：通常保证可串行化调度
- 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。
- 已提交读（READ COMMITTED）：只允许读取已提交数据，但不要求可重复读。
- 未提交读（READ UNCOMMITTED）：允许读取未提交数据。

> 以上所有隔离性级别都不允许 `脏写` ——如果一个数据项已经被另外一个事务写入（尚未提交或中止），则不允许对该数据项执行写操作。

![image-20201119174648073](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119174648073.png)

## 5、多版本并发控制

多版本并发控制（`Multi-Version Concurrency Control, MVCC`）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，==用于实现已提交读和可重复读这两种隔离级别==。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

在实际场景中读操作往往多于写操作，因此又引入了`读写锁`来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，==写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 `CopyOnWrite` 类似==。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，==MVCC 规定只能读取已经提交的快照。==当然一个事务可以读取自身未提交的快照，这不算是脏读。

### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

### Undo日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

![image-20201119194443983](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119194443983.png)

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

###  ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

![image-20201119194608001](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119194608001.png)

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 【也就是该数据行Undo日志的最新版本】与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 已提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在这个数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

### 快照读与当前读

1. 快照读

   MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。

   ```sql
   SELECT * FROM table ...;
   ```

2. 当前读

   MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

   ```sql
   INSERT;
   UPDATE;
   DELETE;
   ```

   在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。

   ```sql
   SELECT * FROM table WHERE ? lock in share mode;
   SELECT * FROM table WHERE ? for update;
   ```

## 6、Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

# 六、索引

## 1、B+树原理

### 与红黑树比较

B+树有着更低的树高，也就意味着磁盘寻道的次数减少，因此B+树更适合文件系统及数据库系统。

## 2、MySQL索引

索引是在存储引擎层实现的，所以不同存储引擎具有不同的索引类型和实现。

### B+树索引

是大多数 MySQL 存储引擎的默认索引类型。

### 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 全文索引

`MyISAM 存储引擎` 支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 `MATCH AGAINST`，而不是普通的 WHERE。

全文索引使用`倒排索引`实现，它记录着关键词到其所在文档的映射。

`InnoDB 存储引擎`在 MySQL 5.6.4 版本中也开始支持全文索引。

### 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

## 3、索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

### 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

### 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 4、索引的优点

- 减少了磁盘扫描的次数
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

## 5、索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。



# 七、切分

## 1、水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力。

![image-20201120102338287](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120102338287.png)

## 2、垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

![image-20201120102415046](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120102415046.png)

## 3、Sharding策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

## 4、Sharding存在的问题

### 事务问题

使用分布式事务来解决

### 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

### ID唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

# 八、复制

## 1、主从复制

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![image-20201120103123091](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120103123091.png)

## 2、读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用`代理方式`来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![image-20201120103306358](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120103306358.png)













