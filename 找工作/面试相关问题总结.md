# Java基础

## 1、抽象类和接口

|           | 抽象类                                | 接口                              |
| --------- | ------------------------------------- | --------------------------------- |
| 继承/实现 | 只能继承一个                          | 可以实现多个                      |
| 实例化    | 不能实例化                            | 不能实例化，但可以声明            |
| 方法      | 为public和protected                   | 为public                          |
| 方法继承  | 必须实现其抽象方法                    | 可以不重写default方法（有方法体） |
| 属性      | 属性可以为 public、private、protected | 属性默认为 public final           |
| 构造器    | 抽象类可以有构造器                    | 接口不能有构造器                  |

## 2、equals和hashCode

equals默认实现是比较两个引用指向的地址是否相同。

![image-20201223202309169](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223202309169.png)

还要注意在重写equals方法的时候要把HashCode方法也重写了，要不然可能出现在根据key修改值时不能覆盖value的情况（因为两次得到的hashCode值不同，因此选择了错误的桶）。

## 3、基本数据类型和引用类型

基本类型有四类八种，byte，short、int、long；float、double；char；boolean。

引用类型：类、接口、数组

基本数据类型保存的值，而引用类型保存的是对象的地址，所有基本类型赋值是按值传递（拷贝赋值），引用类型赋值是按引用传递。

## 4、Java为什么不能多继承

（1）第一个原因是关于钻石问题的，考虑有个类A有一个方法foo()，然后类 B 和 C 继承自A并拥有自己的foo()方法实现，现在类D 继承自B和C，现在我们引用方法foo()时编译器不知道该调用哪个foo()方法。这也称为钻石问题，因为这种继承情况下的结构类似于4边缘菱形，见下图：

![image-20201223151505987](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223151505987.png)

为什么C++可以支持多重继承而Java不支持？

（2）第二个原因：Java不支持多重继承不是因为技术难度，考虑更多的是代码的可维护性和更清晰的设计，多重继承确实使设计复杂化，并且由于没有很多场景需要多重继承，为了简单起见忽略它是明智决定，但这只是我的推测。

在Java8之后，接口允许存在默认方法，因此Java8的接口实现也会涉及到多继承问题，这时从语言从面规定必须要覆写该方法。

```java
public interface Dog1 {
    default void run() {
        System.out.println("Dog1-----run");
    }
}

public interface Dog2 {
    default void run() {
        System.out.println("Dog2-----run");
    }
}
```

![image-20201223153130375](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223153130375.png)

## 5、String的不可变

## 6、判断对象是否是某类的实例

- `isInstance`与`instanceOf`考虑到了类之间的继承关系；
- `==`、`equals`不考虑类间的继承关系；
- `isAssignableFrom`作用是判断一个类是否是另一个类的子类或子接口。

```java
public class B extends A {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        A c = new B();
        System.out.println(a.getClass() == b.getClass());   // false
        System.out.println(b.getClass() == c.getClass());   // true
        System.out.println(b instanceof A); // true，考虑到类之间的继承关系
        System.out.println(A.class.isInstance(b));  // true
        System.out.println(A.class.isAssignableFrom(B.class)); // true，判断B是A的子类或子接口
    }

}
```

## 7、Java的泛型

Java泛型是一种语法糖，是为了在编译时尽可能发现出错的地方并减少程序员需要做的强制类型转换。为了保持向前兼容性，Java泛型需要擦除机制，即编译时将相关类中的泛型信息擦除并在必要的地方为程序员自动添加上强制类型转换。Java泛型只需要记住以下几点：

1. 虚拟机没有泛型，只有普通的类和方法。

2. 所有类型都用它们的限定类型替换（T使用Object替换，T extends Comparable 使用 Comparable 替换）。

3. 在程序调用泛型方法时，如果擦除了返回类型，编译器会自动插入强制类型转换。

   ![image-20201223213347856](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223213347856.png)

   ![image-20201223213424234](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223213424234.png)

4. 桥方法被用来保存多态。桥方法是为了解决类型擦除和多态之间的冲突。

   ```java
   public class DateInterval extends Pair<LocalDate> {
   
       public DateInterval(LocalDate first) {
           super(first, null);
       }
   
       @Override
       public void setSecond(LocalDate second) {
           if (second.isAfter(getFirst()))
               super.setSecond(second);
       }
   }
   ```

   上面这个类擦除后会变成：

   ```java
   public class DateInterval extends Pair {
   
       public DateInterval(LocalDate first) {
           super(first, null);
       }
       
       public void setSecond(LocalDate second) {
           if (second.isAfter(getFirst()))
               super.setSecond(second);
       }
   }
   ```

   1. 奇怪的是，该类还存在另一个从 `Pair` 继承的 `setSecond` 方法，即`public void setSecond(Object second)`。这显然是一个不同的方法，因为它有一个不同类型的参数——Object。

      考虑下面的代码：

      ```java
      DateInterval interval = new DateInterval(LocalDate.of(1997, 10, 1));
      Pair<LocalDate> pair = interval;
      pair.setSecond(LocalDate.now());
      ```

      希望对 `setSecond` 的调用有多态性，并调用最合适的那个方法。由于 Pair 引用 DateInterval 对象，所以应该调用 `DateInterval.setSecond`。问题在于类型擦除和多态发生了冲突。 要解决这个问题，就需要编译器在 `DateInterval` 类中生成一个桥方法(bridge method)。

      ```java
      public void setSecond(Object second) {
          setSecond((LocalDate)second);
      }
      ```


## 8、Java的反射

在运行状态中，对于任意一个类，我们都能知道它的所有属性和方法；对于任意一个对象，我们都能知道它的所有属性和方法。这种动态调用方法和动态获取属性的功能称为Java的反射机制。

反射的实现主要借助以下4个类：

- Class
- Constructor
- Method
- Field

首先，我们创建的每一个类都是Class对象，称为类对象。JVM在动态加载一个class时，就会为其创建一个Class对象，这个Class对象中包含了该class的所有完整信息，包括类名、包名、父类、实现的接、所有方法、字段等。

==总结来说，Java反射的四大主要用处：== 1. 通过Class对象反射创建其实例对象（使用Class.newInstance方法）；2. 通过反射更改某个对象的某个属性的值；3. 通过反射调用某个对象的某个方法；4. 动态代理创建对象。

## 9、Java的异常

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224104137093.png" alt="image-20201224104137093" style="zoom: 67%;" />

`Error` 和 `RunTimeException` 一般是由程序逻辑错误一起，不需要捕获。

非`RunTimeException` （`CheckedException`），是逻辑处理的错误，必须要捕获并处理。

## 10、Java的动态代理

- 有JDK默认的动态代理，基于`Proxy类`实现，还有`CGLib`的动态代理。

- JDK 要求被代理的类必须实现了接口；如果被代理类没有实现接口，就要使用CGLib。

- CGLib 实现的代理类继承自被代理类，所有对于被代理类为final的情况无法处理，被代理类的final方法也无法代理。

- JDK的动态代理优势在于代理对象生成较CGLib快，但是代理对象方法的执行速度较CGLib慢。在两种代理方式均可使用的情况下，对于那些一次代理后长期使用的对象优先使用CGLib，否则使用JDK动态代理。

## 11 、ArrayList

在创建 `ArrayList`时，如果不指定大小，默认容量为10。

![image-20201224112720958](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224112720958.png)

### 扩容机制

默认会扩容为原来的 1.5 倍，如果该数值小于需要的最少容量，就扩容 minCapacity。如果比 `MAX_ARRAY_SIZE`还大，就扩容为 Integer 的最大值。

![image-20201224112919766](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224112919766.png)

![image-20201224113545596](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224113545596.png)

![image-20201224113559941](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224113559941.png)

### 为什么每次扩容到1.5倍呢

因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍是个经验值，它既能满足性能需求，也不会造成很大的内存消耗。

## 12、HashMap

### 默认初始阀值

默认容量为16，默认负载因子为0.75.

![image-20201224114831327](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224114831327.png)

### JDK8使用的散列算法

key 的 hash 值的计算是通过 `hashCode()` 的高16位异或低16位实现的，`(h = key.hashCode()) ^ (h >>> 16)` ，主要是从速度、功效、质量来考虑的，这么做是为了在table的length较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。

![image-20201224162542885](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224162542885.png)

### hash冲突时链表的插入方法

JDK1.7时使用的头插法。JDK1.8使用的是尾插法。

![image-20201224163332580](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224163332580.png)

![image-20201224163920989](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224163920989.png)

### 多线程rehash时死循环问题

多线程情况下HashMap死循环的问题，以及JDK1.8中如何解决的这个问题？

多线程put时候，如果resize被并发执行的话，就可能出现死循环。**究其出现无限循环的原因，是由于重新散列之后链表中节点的相对顺序会被反转。比如重散列之前key值为3的节点的next节点是key值为7的节点，重散列之后key值为7的节点的next变为了key值为3的节点，相对位置反转了。这个原因会导致HashMap中出现环：**

![image-20201224164113029](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224164113029.png)



JDK1.8的resize方法中在重散列的时候通过`loHead、loTail和hiHead、hiTail`指针保留了链表中元素的相对顺序，解决了这个问题，具体方式见上述JDK1.8 resize方法源码。但JDK1.8在扩容时仍会出现各种问题，如扩容丢数据问题。

### 红黑树

1. 每个节点不是红色就是黑色；
2. 不可能有连在一起的红色节点；
3. 根节点都是黑色；
4. 每个红色节点的两个子节点都是黑色，叶子结点【出度为0】都是黑色。

满足了这些性质就可以近似平衡了。

## 13、使用LinkedHashMap实现LRU

`LinkedHashMap` 在传统的 `HashMap` 基础之上使用双向链表将每个节点连接在了一起：

![image-20201224171204814](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224171204814.png)

**如果在LinkedHashMap的构造函数中指定accessOrder为true的话，则每次有节点被查找到时，这个节点都会从链表中的当前位置移动到链表的尾部，所以双端链表的头部节点总是最近最少被访问的。**利用这个特性，就可以实现LRU Cache：

```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    /* 缓存的容量大小 */
    private int capability;

    public LRUCache(int capability) {
        /* 调用 LinkedHashMap 构造器*/
        super(capability, 0.75F, true);
        /* 指定的缓存容量大小 */
        this.capability = capability;
    }

    /* 实现LRU关键方法，如果map中的元素个数大于缓存最大容量，就删除链表的顶端元素
    *  每次put方法调用之后就会调用这个方法，如果 removeEldestEntry 方法返回true，
    *  就会删除双端链表的头结点，也就是删除最近最少使用节点
    *  */
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capability;
    }
}
```

## 14、TreeMap

`TreeMap`将其内部所有节点组织成了一颗红黑树，从而使得检索、插入、删除操作平均和最差时间都是O(lgn)。

如果程序中对存储的数据集合的操作经常需要得到一些有序的结果，比如查找大于指定元素的所有节点，那么应该使用TreeMap。TreeMap的核心在于其内部数据结构的实现，其提供的一些操作相关的API仅是在红黑树数据结构基础之上进行的一些增删改查的操作而已。

![image-20201224175904778](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201224175904778.png)

## 15、final在Java中的作用

- final修饰基本数据类型变量和引用数据类型变量；
- 被final修饰的变量在编译阶段会被放入常量池中；
- final修饰方法时会锁定方法， 不让任何继承类对其进行修改；
- final修饰类的目的简单明确，表明这个类不能被继承；

## 16、int和Integer有什么区别？

int是基本数据类型之一，而Integer是int对应的包装类，提供了数学运算、字符串转换等基本操作，同时还有**自动装箱和拆箱**功能，可以根据上下文自动转换；另外关于Integer的值缓存，静态工厂方法`valueOf`会利用一个**缓存机制**，默认缓存范围是-128-127之间。

（1）  理解自动装箱、拆箱

自动装箱是Java平台在编译阶段自动进行的转换，保证不同的写法在运行时等价，即生成的字节码是一致的。装箱：`Integer.valueOf()`，拆箱：`Integer.intValue()`；

（2）  基本类型线程安全

基本类型变量需要使用并发手段保证线程安全，如果有线程安全的计算需要，可以使用java.util.concurrent.atomic中的类

（3）  基本类型和引用类型局限性

- 基本类型和Java泛型并不能配合使用

  Java编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。

- 无法高效地表达数据

  基本类型在内存中是一段连续的内存，而对象数组储存的是引用，对象分散储存在不同位置，虽然带来了极大的灵活性，但导致了数据操作的低效，尤其是无法充分利用现代CPU缓存机制。

## 17、BIO、NIO、AIO的区别

BIO：同步阻塞

NIO：同步非阻塞

AIO：异步非阻塞

[Java I/O模型从BIO到NIO和Reactor模式](http://www.jasongj.com/java/nio_reactor/)

[阻塞、非阻塞、多路复用、同步、异步、BIO、NIO、AIO 一锅端（推荐）](https://mp.weixin.qq.com/s/17S9Io1dIS_fihfLk5bsAQ)

### **阻塞IO：**

![image-20210311154103941](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210311154103941.png)

### **非阻塞IO：**

- 需要不停的询问内核是否准备好数据；
- 从内核态拷贝数据到用户态的过程仍然是阻塞的。

![image-20210311154129906](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210311154129906.png)

### **IO多路复用：**

- 解决了`非阻塞IO`时需要不停询问是否准备好数据的问题；
- 从内核态拷贝数据到用户态的过程仍然是阻塞的。
- 使用单个线程通过记录跟踪每一个 `Sock(IO流)` 的状态来同时管理多个IO流，实现了一个线程监控多个IO请求，提高了服务器的吞吐能力。

![image-20210311154359770](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210311154359770.png)

`select`、`poll`、`epoll`都是IO多路复用的具体实现。

**select**

select是第一版IO复用，它的优点是跨平台，几乎所有的操作系统都支持。

缺点是：

- select 只能监视1024个连接，采用数组的方式存储文件描述符。
- select 如果任何一个sock(I/O stream)出现了数据，select 仅仅会返回，但不会告诉是哪个sock上有数据，只能自己遍历查找。

**poll**

- poll 去掉了1024个链接的限制，因为poll采用链表的方式存储文件描述符。
- 

**epoll**

epoll 可以说是 I/O  多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题， 比如：

- 使用红黑树存储文件描述符集合。
- epoll 现在是线程安全的。
- epoll 现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，你不用自己去找了。

### 同步跟异步

同步跟异步的区别在于`数据从内核空间拷贝到用户空间是否是阻塞的`。

## 18、Java的多态

多态指**在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为**，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。

实现多态有 3 个必要条件：

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

[Java多态性：Java什么是多态？](http://c.biancheng.net/view/1001.html)

# Java并发

## 1、线程的状态

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223103122233.png" alt="image-20201223103122233" style="zoom: 67%;" />

### BLOCKED和WAITING区别

以下是`Thread`中的一个枚举类，这个类详细描述了Java中一个线程可能会处于的状态。

可以看出 `BLOCKED` 状态是因为没有获取到锁而不能进入同步代码块。

`WAITING` 状态是因为调用了`Object.wait`、`Thread.join`或者`LockSupport.park` ，该线程需要其他线程唤醒才能继续执行。

与`wating`状态相关联的是**等待队列**，与blocked状态相关的是**同步队列**，一个线程由等待队列迁移到同步队列时，线程状态将会由`wating`转化为`blocked`。

```java
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

### 进程与线程的区别

- 从**定义**上来说，进程是系统进行资源分配的基本单位，线程是CPU调度的基本单位；

- 从包含关系来说，一个进程至少有一个线程，同一个进程中的多个线程之间可以并发执行；

- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用（通过时间片轮询），来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

- 各有优缺点，线程执行和切换开销小，进程切换开销大，但有利于资源的管理和保护。

## 2、Thread.sleep 和 Object.wait

![image-20201223102158689](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201223102158689.png)

### Thread.sleep 和Thread.yield

**Sleep**

- 调用sleep会让当前线程从 `Running` 进入 `Timed Waiting` 状态；
- 其它线程可以使用 `interrupt` 方法打断正在睡眠的线程，这时sleep方法会抛出 `InterruptedException`。

**yield**

- 调用yield会让当前线程从 `Running` 进入 `Runnable` 状态，然后调度执行其他线程；
- 具体的实现依赖于操作系统的的任务调度器；

## 3、多线程的交替输出

线程1打印a，线程2打印b，线程3打印c，交替打印 abc。

### 使用 wait/notify

```java
public class Test1 {
    private volatile int flag = 0;
    private final Object lock = new Object();

    public void print(final char c, final int printFlag) {
        new Thread(() -> {
            synchronized (lock) {
                while (flag <= 21) {
                    while (flag % 3 != printFlag) {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println(c);
                    flag++;
                    lock.notifyAll();
                }
            }
        }).start();
    }

    public static void main(String[] args) {
        Test1 test = new Test1();
        test.print('a', 0);
        test.print('b', 1);
        test.print('c', 2);
    }
}
```

### 使用 await/signal

```java
public class Test1 {
    private volatile int flag = 0;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition printA;
    private final Condition printB;
    private final Condition printC;

    public Test1() {
        printA = lock.newCondition();
        printB = lock.newCondition();
        printC = lock.newCondition();
    }

    public void print(final char c, final int printFlag, final Condition condition, final Condition nextCondition) {
        new Thread(() -> {
            lock.lock();
            try {
               while (flag <= 21) {
                   while (flag % 3 != printFlag) {
                       condition.await();
                   }

                   System.out.println(c);
                   flag++;
                   nextCondition.signalAll();
               }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }).start();
    }

    public static void main(String[] args) {
        Test1 test = new Test1();
        test.print('a', 0, test.getPrintA(), test.getPrintB());
        test.print('b', 1, test.getPrintB(), test.getPrintC());
        test.print('c', 2, test.getPrintC(), test.getPrintA());
    }

    public Condition getPrintA() {
        return printA;
    }

    public Condition getPrintB() {
        return printB;
    }

    public Condition getPrintC() {
        return printC;
    }
}
```

## 4、ReentrantLock和synchronized

ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：

- `等待可中断`：是指当持有锁的线程长期不释放锁的时候，正在等待的线程**可以选择放弃等待**，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。
- `公平锁`：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。`synchronized`中的锁是非公平的，`ReentrantLock`在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致`ReentrantLock`的性能急剧下降，会明显影响吞吐量。
- 锁绑定多个条件：是指一个`ReentrantLock`对象可以同时绑定多个`Condition`对象。在`synchronized`中，锁对象的`wait()`跟它的`notify()`或者`notifyAll()`方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而`ReentrantLock`则无须这样做，多次调用`newCondition()`方法即可。



推荐在`synchronized`与`ReentrantLock`都可满足需要时优先使用`synchronized`：

- `synchronized`是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉`synchronized`，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐`synchronized`。
- Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则==可以由Java虚拟机来确保即使出现异常，锁也能被自动释放==。
- 尽管在JDK 5时代`ReentrantLock`曾经在性能上领先过`synchronized`，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对`synchronized`来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录`synchronized`中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。

## 5、线程安全的集合类

线程安全的集合类主要分为3种：

![image-20210223091723582](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223091723582.png)

![image-20210303084657127](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210303084657127.png)

## 6、ConcurrentHashMap

### JDK1.7

在JDK1.7中，`ConcurrentHashMap` 是由 `Segment` 数组和 `HashEntry` 数组构成，采用分段锁来保证安全性。

`Segment` 是 `ReentrantLock` 重入锁；`HashEntry` 则用于存储键值对数据。

一个 `ConcurrentHashMap` 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构。

![image-20210223105732093](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223105732093.png)

### JDK1.8

在JKD1.8中，已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 `Synchronized + CAS` 来操作，整个看起来就像是优化过且线程安全的 HashMap。

Java8使用CAS + synchronized 来保证实现put操作：如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。

![image-20210223105940234](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223105940234.png)

### JDK1.8中为什么要摒弃分段锁

- **jdk1.8中锁的粒度更细了**。jdk1.7中ConcurrentHashMap 的concurrentLevel（并发数）基本上是固定的。jdk1.8中的concurrentLevel是和数组大小保持一致的，每次扩容，并发度扩大一倍。

- **红黑树的引入**，对链表的优化使得 hash 冲突时的 put 和 get 效率更高。

- **获得JVM的支持** ，ReentrantLock 毕竟是 API 这个级别的，后续的性能优化空间很小。 synchronized 则是 JVM 直接支持的， JVM 能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得 synchronized 能够随着 JDK 版本的升级而不改动代码的前提下获得性能上的提升。

参考：[ConcurrentHashMap 原理浅析](https://juejin.cn/post/6844904018729254926#heading-0)

## 7、Iterator 和 ListIterator

（1）ListIterator是Iterator是子接口，都是迭代器；

（2）ListIterator只能应用于List及其子类型，Iterator可以应用于所有集合；

（3）ListIterator支持逆向遍历、定位索引、添加或修改对象，Iterator不支持。

## 8、HashMap和HashTable

`HashTable`实现线程安全的方式比较简单，就是公开的方法比如get、put都使用了`synchronized`描述符。而遍历视图比如keySet都使用了`Collections.synchronizedXXX`进行了同步包装。

![image-20210207095041105](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210207095041105.png)

![image-20210207095145950](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210207095145950.png)

HashTable JDK1.0出现，HashMap JDK1.2出现。HashTable底层数据结构为`数组+链表`，不含红黑树。

HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出`NullPointerException`异常。

`HashMap`对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。

![image-20210207095900351](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210207095900351.png)

![image-20210207095956373](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210207095956373.png)

## 9、BlockingQueue的实现类

- `ArrayBlockingQueue`
- `LinkedBlockingQueue`
- `PriorityBlockingQueue`
- `DelayQueue`
- `SynchronousQueue`

## 10、volatile关键字

一个变量被定义成volatile之后，它将具备两项特性：

1. 保证此变量对所有线程的可见性。每次使用之前都会刷新值。
2. 通过插入内存屏障禁止指令重排序优化。

![image-20210302212159968](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210302212159968.png)

## 11、先行发生原则

**先行发生原则**是指前一个操作的结果可以被后续的操作获取。

Java内存模型下，有一些天然的先行发生关系。

## 12、synchronized实现和锁优化

`synchronized`关键字修饰的代码段，在JVM中是被编译为`monitorenter`、`monitorexit`指令完成锁的获取和释放操作的。解释器执行`monitorenter`指令时和`monitorexit`会进入到jvm中的某个函数，在这些函数中完成锁的偏向锁到轻量级锁到重量级锁到释放锁的整个流程。

### 偏向锁

轻量级锁在没有竞争时，每次重入仍然需要执行CAS操作，

在JDK6中引入了偏向锁来优化：==只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。==

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。根据锁对象目前是否处于锁定状态决定是否撤销偏向（偏向模式设置为“0”）。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。状态转化及对象 `Mark Word` 的关系如下：

![image-20201230155742007](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201230155742007.png)

偏向锁的工作过程：

1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。
2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
5. 执行同步代码。

偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：`-XX:-UseBiasedLocking=false`，关闭之后程序默认会进入轻量级锁状态。

### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。

“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。

> 当锁处于偏向锁时，如果被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

轻量级锁的工作过程：

1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（`Lock Record`）的空间，用于存储锁定对象的 `Mark Word`。

2. 将`Lock Record`里的`owner`指针指向锁对象，并使用CAS操作尝试将对象的`Mark Word`更新为指向`Lock Record`的指针，将`Mark Work` 存入`Lock Record`。

   ![image-20210208202104091](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210208202104091.png)

3. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象`Mark Word`的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

4. 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的`Mark Word`是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁，执行步骤5。

5. 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

### 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时`Mark Word`中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

- 当轻量级锁膨胀为重量级锁时，需要为Object对象申请 Minitor锁，让Object对象指向重量级锁地址。然后其他的线程进入Monitor的EntryList BLOCKED

![image-20210208221649639](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210208221649639.png)

- 当 Thread-0 退出同步块解锁时，使用 cas 将 `Mark Word` 的值恢复给对象头，失败【因为此时已经升级为重量级锁，标记为10】。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，然后唤醒 EntryList 中 BLOCKED 线程。

![image-20201230161613623](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201230161613623.png)

参考：[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)

## 13、线程池

![image-20201231151506595](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201231151506595.png)

### 任务拒接策略有哪几种

- `ThreadPoolExecutor.AbortPolicy`：丢弃任务并抛出`RejectedExecutionException`异常。
- `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常
- `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（先尝试将此任务加入到任务队列中，之后等待执行，如果加入队列还失败，则继续丢弃队列最前面的任务，重复此过程）
- `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务

### 创建线程池的几种方法

### 线程池都有哪些状态？

### submit和execute方法的区别

- `execute`：
  - 只能提交 `Runnable` 接口的对象，我们知道 `Runnable` 接口的run方法是没有返回值的。
  - execute方法提交的任务异常是直接抛出的
- `submit`：
  - 可以提交`Runnable`也可以提交`Callable`对象，即可以有返回值，也可以没有。
  - submit方法是捕获了异常的，当调用FutureTask的get方法时，才会抛出异常。



### shutdown和shutdownNow

- `shutdown` 方法被调用时，线程池的状态则立刻变成`SHUTDOWN`状态。此时，则不能再往线程池中添加任何任务，否则将会抛出`RejectedExecutionException`异常。但是，此时线程池不会立刻退出，而是会等添加到线程池中的任务都已经处理完成，才会退出。 

- `shutdownNow` 方法会把线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。

## 14、Java内存模型

==Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异==，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

### 主内存和工作内存

所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，线程的工作内存中保存了该线程使用的变量的主内存副本。

线程对变量的操作（读取、赋值等）必须在工作内存中进行，线程之间的变量值传递需要通过主内存来完成。

![image-20201228204735703](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201228204735703.png)

### 内存间交互操作

![image-20201228210248310](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201228210248310.png)

Java内存模型中定义了8种操作来完成主内存和工作内存之间的交互。

- lock（锁定）：作用于主内存的变量，标识一个变量的状态为线程独占。
- unlock（解锁）：作用于主内存的变量，释放处于锁定状态的变量。
- read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到工作内存中。
- load（载入）：作用于工作内存中，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中。
- use（使用）：作用于工作内存中，把工作内存中一个变量的值传递给执行引擎。
- assign（赋值）：作用于于工作内存中，把一个从执行引擎接收到的值赋给工作内存的变量。
- store（存储）：作用于工作内存中，把工作内存的一个变量的值传送到主内存中。
- write（写入）：作用于主内存中，在 store 之后执行，把 store 得到的值放入主内存的变量中。

### 内存模型如何实现三大特性

#### 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，可以说对基本数据类型的访问、读写都具备原子性。如果需要更大程度上的原子性，则需要lock 和 unlock 的参与，反映到代码层面上就是同步块，即 synchronized关键字。

#### 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。

Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

主要有三种实现可见性的方式：

- volatile
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

#### 有序性

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了`指令重排序`和`工作内存和主内存同步延迟`。

在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

> 综上，synchronized 关键字是万能的，能同时保证上面3条特性。

> JVM内存模型分为主内存和工作内存，线程对主内存中的共享变量进行操作时，需要拷贝一个副本到自己的工作内存中，那么问题来了，如果这个共享变量很大怎么办？例如List对象，也是全部拷贝吗？JVM是如何解决的？

## 15、CPU消耗较高的原因

1. 程序中存在类似于while true这样一直占用cpu的死循环，注意阻塞在synchronized上的死锁线程并不会很占用cpu，因为这种死锁线程都处于阻塞状态。

2.  GC很频繁，GC线程属于CPU密集型，GC过程一般是并发执行的。

3. 如何定位最消耗CPU的线程：

   Top（找到是哪个线程最占用cpu） + jstack（首先通过jps确定我们当前执行java的任务的进程号，之后找到此线程对应的java进程） 

参考：[如何定位消耗CPU最多的线程](http://lovestblog.cn/blog/2016/03/31/cpu-thread/)

## 16、Java中避免死锁

1. 使用乐观锁机制
2. 减少锁粒度，这可以在一定程度上避免死锁。
3. 控制加锁顺序
4. 有时限的或者可中断的去加锁
5. 死锁后程序能够自动的检测出来

## 17、Java中线程通信的方式

1. 锁机制：包括互斥锁（`Synchronized`、`ReentrantLock`、`ReentrantReadWriteLock`等）

2. 条件变量机制：比如使用volatile关键字标识的boolean类型的变量或者`AtomicInteger`类的对象等进行线程间的同步。

3. 基于锁机制衍生出的一些通信方式：比如基于Synchronized衍生出的wait-notify机制，基于ReentrantLock衍生出的Condition.await和signal机制（这个机制就可以用来实现`ArrayBlockingQueue`）

4. juc包中的一些工具类也可以用来实现线程间的通信，比如`CountdownLatch`、`CyclicBarrier`、`Semphore`。这些类底层其实都是基于AQS框架来实现的。

## 18、同一个线程能不能start两次

不能，start方法是线程安全的，其内部在进行实际的start操作之前会判断线程状态是否为NEW，如果不为NEW，会抛出`illegalThreadStateException`。

```java
/** 线程成员变量，默认为0，volatile修饰可以保证线程间可见性 */
private volatile int threadStatus = 0;
/* 当前线程所属的线程组 */
private ThreadGroup group;
/**
 * 同步方法，同一时间，只能有一个线程可以调用此方法
 */
public synchronized void start() {
    // A zero status value corresponds to state "NEW".
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    group.add(this);

    boolean started = false;
    try {
        start0();	// 本地方法，该方法会修改 threadStatus变量【修改后不再为0】，实际调用run方法
        started = true;
    } finally {
        try {
            if (!started) {
                // 创建失败，则从线程组中删除该线程
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}
```

## 19、Lock下的实现类

- `ReadWriteLock`，悲观锁

- `StampedLock`，乐观锁

## 20、AQS

AQS全称是 `AbstractQueuedSynchronizer`，是阻塞式锁和相关的同步器工具的框架。

特点：

- 用 state 属性来表示资源的状态（分为独占模式和共享模式）
  - `compareAndSetState` ：CAS机制设置 state 状态
  - 独占模式 是只有一个线程能够访问资源，共享模式 可以允许多个线程访问资源
- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

子类主要实现这样一些方法（默认抛出 `UnsupportedOperationException`） 

- `tryAcquire`
- `tryRelease`
- `tryAcquireShared` 
- `tryReleaseShared` 
- `isHeldExclusively`

获取锁的方法：

```java
// 如果获取锁失败
if (!tryAcquire(arg)) {
 // 入队, 可以选择阻塞当前线程 park unpark
}
```

释放锁的方法：

```java
// 如果释放锁成功
if (tryRelease(arg)) {
 // 让阻塞线程恢复运行
}
```

## 21、Semaphore

`Semaphore` 用于限制能同时访问共享资源的线程上限。

```java
public class SemaphoreTest {

    public static void main(String[] args) {
        // 一次最多允许3个线程运行
        Semaphore semaphore = new Semaphore(3);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println("start...");
                    // 休眠1秒
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println("end...");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            }, "Thread-" + i).start();
        }
    }
}

/**
start...
start...
start...
end...
end...
end...
start...
start...
start...
end...
end...
end...
start...
start...
start...
end...
end...
end...
start...
end...
*/
```



## 22、CountDownLatch

用来进行线程同步协作，等待所有线程完成倒计时。

- `await()` 被调用后，当前线程会进入等待状态，在计数器归0后会被唤醒。
- `countDown()` 每次调用会让计数器的值减1

```java
public class CountDownLatchTest {

    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(3);
        ExecutorService service = Executors.newFixedThreadPool(4);

        service.submit(() -> {
            System.out.println("t4 run");
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("t4 end");
        });
        service.submit(() -> {
            System.out.println("t1 run");
            // 休眠1秒
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            countDownLatch.countDown();
            System.out.println("t1 end");
        });
        service.submit(() -> {
            System.out.println("t2 run");
            // 休眠2秒
            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
            countDownLatch.countDown();
            System.out.println("t2 end");
        });
        service.submit(() -> {
            System.out.println("t3 run");
            // 休眠3秒
            try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
            countDownLatch.countDown();
            System.out.println("t3 end");
        });
        service.shutdown();
    }

}

/**
t4 run
t1 run
t2 run
t3 run
t1 end
t2 end
t3 end
t4 end
*/
```



## 23、CyclicBarrier

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 `await()` 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 `await()` 方法而在等待的线程才能继续执行。

`CyclicBarrier` 和 `CountdownLatch` 的一个区别是，CyclicBarrier 的计数器通过调用 `reset()` 方法可以循环使用，所以它才叫做循环屏障。

`CyclicBarrier`有两个构造函数，其中 `parties` 指示计数器的初始值，`barrierAction` 在所有线程都到达屏障的时候会执行一次。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```

```java
public class CyclicBarrierTest {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(2, () -> {
            System.out.println("thread-1,thread-2 finish...");
        });
        ExecutorService service = Executors.newFixedThreadPool(2);
        for (int i = 1; i <= 2; i++) {
            int k = i;
            service.submit(() -> {
                System.out.println("thread-" + k +" start...");
                // 休眠k秒
                try {
                    TimeUnit.SECONDS.sleep(k);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    barrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println("thread-" + k +" end...");
            });
        }
        service.shutdown();
    }
}

/**
thread-1 start...
thread-2 start...
thread-1,thread-2 finish...
thread-2 end...
thread-1 end...
*/
```



# JVM

## 1、JVM的内存模型

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201005224109716.png" alt="image-20201005224109716" style="zoom: 80%;" />



- 程序计数器：是程序控制流的指示器。

- 虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，其内部保存着一个个的栈帧（`Stack Frame`），对应着一次次的Java方法调用。

  ![](https://gitee.com/yanjundong97/picBed/raw/master/images/20201029152149.png)

- 本地方法栈：

- 堆：年轻代（Eden、S0、S1） + 老年代

- 方法区：用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

  | 版本         | 细节                                                         |
  | ------------ | ------------------------------------------------------------ |
  | jdk1.6及之前 | 有永久代，`静态变量存放在永久代中`                           |
  | jdk1.7       | 有永久代，但已经逐渐“去永久代”，`字符串常量池、静态变量移除，保存到堆中`。 |
  | jdk1.8及之后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但`字符串常量池、静态变量仍在堆中` |

## 2、字符串常量池为什么调整位置

在JDK7中将字符串常量池放到了堆空间中，因为永久代的回收效率很低，只有在 full gc 时才会触发，而 full gc 只有在老年代不足、永久代不足时才会触发，这就导致了StringTable的回收效率很低。

但是我们开发中会有大量的字符串被创建，回收效率低导致永久代内存不足，放到堆中，能够及时回收内存。

## 3、JVM的调优参数

- -xss：每个线程虚拟机栈的大小，一般情况下256k足够了，默认值是1M。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
- -xms：堆的初始值大小。
- -xmx：堆的最大值大小，通常情况下会将-xms和-xmx设置为一样的，因为当heap不够而发生扩容时，会引起内存的抖动，影响程序运行时的稳定性。最大堆的大小一定要小于可用的物理内存，以免发生过多的内外存之间的页面交换。

**设置好堆内存之后，除了通过`-NewRatio`的方式设置新老年代的比例来确定新生代的大小。**

## 4、所有的对象和数组都分配在堆吗

不一定。随着JIT编译器的发展和`逃逸分析技术`的成熟，如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，就可以被优化为栈上分配。就样就不需要在堆上分配内存，也不需要垃圾回收。

## 5、String的intern方法

```java
String s = new String(“a”);
s.intern();
```

![image-20201225180105956](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225180105956.png)

在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。

![image-20201225180215855](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225180215855.png)

## 6、对象的创建过程

1. 检查类是否被加载、链接、初始化。如果没有，需要先执行相应的类加载过程。
2. 为新生对象分配内存，对象所需内存大小在类加载完成后就可以确定。分配对象的方法有指针碰撞和空闲列表。
3. 将分配到的内存空间（不包括对象头）都初始化为零值。
4. 设置对象的对象头。
5. 执行`<init> `方法对成员变量进行初始化， 并执行对象的构造函数。

![image-20201225204740751](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225204740751.png)

## 7、对象的访问定位

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225211232732.png" alt="image-20201225211232732" style="zoom:80%;" />

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225211245552.png" alt="image-20201225211245552" style="zoom:80%;" />

## 8、如何判断对象已死

1. 引用计数，给对象中添加一个引用计数器，每当有地方引用他时，计数器值就加1；当引用失效时，计数器值就减1，任何时刻引用计数为0的对象就是不可回收的。它的缺陷在于很难解决循环引用的问题。

2. 可达性分析算法。
   - 以 `GC Roots` 为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为`引用链（ReferenceChain）`
   - 如果某个对象到`GC Roots`间没有任何引用链相连，或者用图论的话来说就是从 `GC Roots` 到这个对象不可达时，则证明此对象是不可能再被使用的。

![image-20200823144023394](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200823144023394.png)

> 虚拟机创建的 `Finalizer`线程会去触发 `finalize()`方法，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 `finalize()` 方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。

## 9、GC Roots有哪些？

Java语言中，固定可作为 `GC Roots` 的对象包括以下几类元素：

- 虚拟机栈中引用的对象
  - 比如：各个线程被调用的方法堆栈中使用到的参数、局部变量等

- 本地方法栈内JNI（通常说的本地方法）引用的对象
- 方法区中类静态属性引用的对象
  - 比如：Java类的引用类型静态变量
- 方法区中常量引用的对象
  - 比如：字符串常量池（StringTable）里的引用
- 所有被同步锁（synchronized关键字）持有的对象
- Java虚拟机内部的引用
  - 比如：基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

> 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

## 10、记忆集(Remembered Set)

分代收集理论：

- 绝大多数对象都是朝生夕死的。
- 熬过越多次垃圾收集的对象就越难以消亡。

基于这个理论有了新生代和老年代。

### 为什么要有记忆集

新生代中的对象有可能会被老年代所引用，如果每次进行`Minor GC` 除了固定的 `GCRoots`外，还需要把老年代的对象遍历一次，这样的效率是很低的。但根据第三条经验原则：

- 跨代引用相对于同代引用只占极少数。

所以不需要为每个对象记录是否存在跨代引用，只需要在新生代上建立一个全局的数据结构（这个结构就是`Remembered Set`），这个结构把老年代划分为若干个块，并标记出哪个块存在跨代引用。在进行 `Minor GC` 时，把包含跨代引用的这块内存里的对象加入 `GC Roots` 扫描即可。

### Remembered Set

`Remembered Set`记录了某一块内存区域内的对象是否引用了收集区域的对象。实现方法有3种粒度：

- 字长精度，记录一个机器字长，也就是处理器的寻址位数，这个位置包含跨代引用。
- 对象精度，记录包含跨代引用的对象。
- 卡精度，每个记录对应到一块内存区域，该区域上包含跨引用对象。

卡表类似于一个数组，每个元素对应了一块特定大小的内存块，这个内存块称为 ”卡页“。HotSpot使用的卡页大小为2的9次幂，也就是512字节。如果该区域内有跨代引用对象，就将该元素的值标记为1， 称这个元素变脏。在垃圾收集时，只要筛选出变脏的元素，就能轻松得到哪些内存块中包含跨代指针，把它们加入`GC Roots` 一并扫描。

## 11、垃圾收集算法

### 标记-清除算法

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200823220111548.png" alt="image-20200823220111548" style="zoom:80%;" />

### 复制算法

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200824092210116.png" alt="image-20200824092210116" style="zoom:67%;" />

### 标记-压缩算法

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200824101521208.png" alt="image-20200824101521208" style="zoom:67%;" />

## 12、垃圾收集器

![image-20201225221242878](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201225221242878.png)

### Serial回收器：串行回收

这个收集器是一个 `单线程工作` 的收集器，但它的“单线程”并不只是说它==只会使用一个CPU或一条收集线程去完成垃圾收集工作==，更重要的是在它进行垃圾收集时，==必须暂停其它所有工作的线程==，直到它收集结束。

![image-20200827095954119](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200827095954119.png)

Serial回收器的优点是：

- 简单而高效（与其它收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里==额外内存消耗最小==的。对于单核CPU来说，Serial由于没有线程交互的开销，因为有着更高的垃圾收集效率。
- 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。
- 在HotSpot虚拟机中，使用`–XX:+UseSerialGc`参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用`serial Gc`，且老年代用`serial old Gc`。

### ParNew回收器：并行回收

`ParNew` 收集器实质上是 `Serial` 收集器的多线程并行版本，并没有多大的创新之处。

到现在官方更希望它完全被 `G1` 所取代，加上取消了`Serial+CMS`、`ParNew+Serial Old`的组合使用，到目前 `ParNew` 只能和 `CMS` 搭配使用。

![image-20200827102704674](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200827102704674.png)

> 在单核心的环境下，ParNew收集器绝对不会有比Serial收集器更好的效果。 

### Parallel回收器：吞吐量优先

`Parallel Scavenge` 收集器与其他收集器的不同在于，其它收集器的关注点是尽可能减少 `Stop The World` 的时间，而 `Parallel Scavenge` 更关注达到一个可控制的吞吐量（Throughput）。

> 吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。
>
> 停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验。
>
> 高吞吐量则可以最高效率利用处理器资源，尽快完成运算任务，主要适合后台运算的分析任务。例如工资支付、科学计算、日志分析的应用。

`自适应调节策略` 是 `Parallel Scavenge` 与 `ParNew` 的一个重要区别。`自适应调节策略` 是指虚拟机会根据当前系统的运行情况，动态调整虚拟机参数以提供最合适的停顿时间或者最大的吞吐量。

![image-20200827105448084](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200827105448084.png)

> 在Java8中，默认使用此垃圾收集器。

### CMS回收器：低延迟

`Concurrent-Mark-Sweep GC` 。 

`CMS` 是一个==以获取最短回收停顿时间为目标==的收集器。这款收集器是 `HotSpot` 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

> 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
> `CMS收集器` 就非常符合这类应用的需求。

CMS收集器是采用` 标记-清除` 算法。

![image-20200827112747789](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200827112747789.png)

1. 初始标记（`initial mark`）：仅仅只是标记一下 `GC Roots` 能直接关联到的对象，速度很快；
2. 并发标记（`concurrent mark`）：从`GC Roots`的直接关联对象开始遍历整个对象图的过程，这个过程比较耗时，但不需要 `STW`。
3. 重新标记（`remark`）：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间通常会比`初始标记阶段`稍长一些，但也远比并发标记阶段的时间短。
4. 并发清除（`concurrent sweep`）：清理删除掉标记阶段判断已经死亡的对象，==由于不需要移动存活对象，所以这个阶段也不需要 `STW`==，当然这也导致了只能使用`Mark-Sweep` 算法，会造成内存碎片问题，进而不能使用`指针碰撞`方法分配对象所需内存空间（使用 `空闲列表` 法）。

#### 优缺点

优点：

- 并发收集
- 低延迟，`mark-sweep`分为多个阶段，其中一大部分阶段GC的工作是和Application threads的工作同时进行的（当然，gc线程会和用户线程竞争CPU的时间），默认的GC的工作线程为`（处理器核心数量 +3）/4`；

缺点：

- 使用`标记-清除`算法，会造成内存碎片。
- CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
- CMS收集器无法处理`浮动垃圾`。可能出现`Concurrent Mode Failure`失败而导致另一次`Full GC`的产生。在并发标记和并发清理阶段，用户线程还在继续运行，那么就会产生新的垃圾对象，但因为这些垃圾出现在标记过程之后，CMS无法在此次收集中处理掉它们，只能留在下一次GC时清理。这一部分垃圾就是 “浮动垃圾”。也正是因为在垃圾收集阶段用户线程还在运行，所以就需要留下足够的空间来存放对象，不能够像其他收集器一样等老年代几乎满了才去收集。`-XX:CMSInitiatingOccu-pancyFraction`可以调节CMS的触发百分比，但这个值设置的太高会导致CMS收集过于频繁，设置的太低会导致不能满足程序分配新对象的需求，这时会出现`并发失败`，启动预备方法：使用 `Serial Old` 方法来进行垃圾收集，但这样停顿时间就更长了。

### G1回收器：区域化分代式

`Garbage First`

官方给G1设定的目标是==在延迟可控的情况下获得尽可能高的吞吐量==，所以才担当起了`全功能收集器` 的重任与期望。

![image-20200827205412079](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20200827205412079.png)

- 初始标记（`Initial Marking`）：仅仅==只是标记一下GC Roots能直接关联到的对象==，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
- 并发标记（`Concurrent Marking`）：从GC Root开始对堆中对象进行可达性分析，==递归扫描整个堆里的对象图，找出要回收的对象==，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
- 最终标记（`Final Marking`）：对用户线程做另一个短暂的暂停，用于==处理并发阶段结束后仍遗留下来的最后那少量的SATB记录==。
- 筛选回收（`Live Data Counting and Evacuation`）：负责==更新Region的统计数据，对各个Region的回收价值和成本进行排序==，根据用户所期望的停顿时间来==制定回收计划==，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程（STW），由多条收集器线程并行完成的。

#### 与CMS收集器的比较

G1 > CMS

1. Region之间采用标记-复制算法，从整体上看采用的是标记-整理算法，因此不会出现内存碎片。
2. 可以指定最大停顿时间。G1除了追求低停顿外，还能建立`可预测的停顿时间模型`，能让使用者==明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒==【默认的停顿目标为200毫秒】。G1的具体回收思路是：G1收集器去跟踪各个Region里面的垃圾堆积的价值大小（价值即回收所获得的空间大小以及回收所需时间的经验值），然后在后台维护一个优先级列表，==每次根据允许的收集时间，优先回收价值最大的Region==。保证了G1收集器在有限的时间内获取尽可能高的收集效率。
3. G1垃圾收集的目标范围不再是整个新生代或者整个老年代或者整个堆空间，而是可以面向堆内存的任何部分来进行回收，回收的标准不再是它属于哪个年代，而是回收的价值大小。这就是G1收集器的`Mixed GC`模式。
4. 每个Region可以根据需要扮演新生代的Eden空间、Survivor空间，或者Old空间，收集器能够==对扮演不同角色的`Region`采用不同的策略去处理== 。不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量，更加灵活。

CMS > G1

- 在用户程序运行过程中，G1无论是为了垃圾收集产生的==内存占用(Footprint）【G1要为每个Region维护一个记忆集，CMS则只需要维护老年代到新生代的引用】==还是程序运行时的==额外执行负载（overload）==都要比CMS要高。

- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而==G1在大内存应用上则发挥其优势==。平衡点在6-8GB之间。

## 13、为什么引入class文件

1. 减少准备工作的耗时，如果每次都从源码开始解释执行，那么每次执行都需要检查语法、句法、语义的合法性。
2. 提供兼容性，也可以把Python、JS等其他语言解析成字节码文件去执行。

## 14、类的加载过程

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201005224318647.png" alt="image-20201005224318647" style="zoom:80%;" />

![image-20201228101449585](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201228101449585.png)

类加载过程中的加载、验证、准备、初始化、使用和卸载这五个阶段的顺序都是确定的，类型的加载必须按照这种顺序按部就班的开始。**只有解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定机制。**

## 15、类的`<clinit>`会多次调用吗

**同一个类加载器下，一个类的`<clinit>`方法只能执行一次，虚拟机会确保一个类的`<clinit>()`方法在多线程环境中被正确的加锁、同步。如果多线程同时去初始化一个类，那么只有一个线程去执行这个类的`<clinit>`方法，其它线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。**

## 16、什么时候进行类初始化

在以下情况下，类必须进行 “初始化”。

![image-20201228104203476](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201228104203476.png)

## 17、类加载器

- **引导类加载器**
  - 这个类加载器使用 `C/C++` 语言实现，嵌套在 JVM 内部
  - 用来加载 Java 的核心库（），用于提供 JVM 自身需要的类
  - 并不继承`java.lang.classLoader`，没有父加载器
  - 加载扩展类和应用类加载器，并指定为他们的父类加载器。
  - 出于安全考虑，`Bootstrap` 启动类加载器只加载包名为` java、javax、sun`等开头的类
- **扩展类加载器**
  - `Java语言编写`，由 `sun.misc.Launcher$ExtClassLoader` 实现。
  - 派生于classLoader类
  - 父类加载器为启动类加载器
  - 从 `java.ext.dirs` 系统属性所指定的目录中加载类库，或从JDK的安装目录的 `jre/lib/ext` 子目录（扩展目录）下加载类库。==如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载==。
- **系统类加载器**
  - java语言编写，由 `sun.misc.Launcher$AppclassLoader` 实现
  - 派生于classLoader类
  - 父类加载器为扩展类加载器
  - 它负责加载环境变量`classpath`或系统属性 java.class.path 指定路径下的类库
  - ==该类加载是程序中默认的类加载器==。一般来说，Java应用的类都是由它来完成加载
  - 通过`ClassLoader#getSystemClassLoader()`方法可以获取到该类加载器

## 18、双亲委派机制

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201011202053566.png" alt="image-20201011202053566" style="zoom: 80%;" />

**优点：**

- 避免了类的重复加载
- 保护程序安全，防止核心的 API 被篡改
  - 自定义类：`java.lang.String`

**缺点：**

判断类是否加载的时候，应用类加载器会顺着双亲路径往上判断,直到启动类加载器。但是启动类加载器不会往下询问，这个委托路线是单向的，即顶层的类加载器，无法访问底层的类加载器所加载的类。

如果上层的类加载器所加载的基础代码需要回调用户的代码，双亲委派模型就不得不被打破了。典型的例子就是SPI机制，也就是父加载器请求子类加载器去完成类加载的动作，打破了双亲委派模型。

## 19、沙箱安全机制

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201011203134433.png" alt="image-20201011203134433" style="zoom: 80%;" />

> 在JVM中判断两个class类是否为同一个类的两个必要条件：
>
> - 类的包名、类名一样
> - 加载这个类的 `ClassLoader` 必须相同

# Redis

## 1、5种数据类型

- String
- List（ziplist+链表）
- Set（hash）
- Hash（hashmap）
- ZSet（skiplist）

### 其他的用法

- Geospatial

## 2、Redis的key删除策略

![](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120163022213.png)

## 3、Scan和keys

Redis中使用 `keys`指令可以列出满足特定正则表达式的key。但是这个指令存在2个很明显的缺陷：

- 没有offset、limit参数。
- 是遍历算法，时间复杂度是O(n)。如果实例中的key较多，会造成服务器卡顿，其他的指令必须处于等待状态。

`Scan`指令相比较`keys`的特点：

- 复杂度也是O(n)，但它是通过游标分步进行的，不会阻塞线程。
- 提供了limit参数。但是这个参数不是限制返回的条数，是指遍历的最大槽。
- 同`keys`一样，提供了模式匹配功能。
- 服务器不需要为游标保存状态，游标的唯一状态就是scan返回给客户端的游标整数。
- 返回的结果可能会有重复，需要客户端去重。
- 遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的。
- 单次返回的结果是空的不能说明遍历结束，而要看返回的游标是否为零。

## 4、Redis与Memcached

两者都是非关系型内存键值数据库，主要有 以下不同：

1. 数据类型

   Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。

2. 数据持久化

   Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。这也就意味着重启后Redis可以恢复数据，但Memcached 不可以。

3. 分布式

   Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

   Redis Cluster 实现了分布式的支持。

4. 内存管理机制
   - 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘【key仍然会在内存】，而 Memcached 的数据则会一直在内存中。
   - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

## 5、Redis的持久化机制

- RDB
- AOF

## 6、Redis的哨兵机制

- **监控（Monitoring**）： 会不断地检查主节点和从节点是否运作正常。
- **提醒（Notification）**： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- **自动故障迁移（Automatic failover）**： 当一个主服务器不能正常工作时， `Sentinel` 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

## 7、RedLock算法

![image-20201124173338821](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201124173338821.png)

## 8、hash的扩容和rehash

Redis的hash扩容和Java中的hash扩容不同，在扩大一倍容量后，不会把所有的key rehash到新的数组，它是采用了一种`渐进式的rehash方式`。在开始时保留新旧两个hash结构，查询时会同时查询两个hash结构，然后在后续的定时任务以及hash操作指令（来自客户端的hset和hdel指令）中，一点一点转移。当搬迁任务完成后，就会完全使用新的hash结构。

## 9、Redis的多路复用IO



## 10、Redis的缓存一致性问题

此时主要需要考虑2个问题：

1. 执行顺序问题：先更新缓存还是先更新数据库；
2. 更新缓存的策略问题：是选择修改缓存数据，还是直接淘汰缓存；

针对这两个问题，共有4中解决方案：

  1、先更新缓存，再更新数据库；
  2、先更新数据库，再更新缓存；
  3、先淘汰缓存，再更新数据库；
  4、先更新数据库，再淘汰缓存。

### **更新Cache还是淘汰Cache？**

**淘汰Cache**

优点：操作简单，直接将缓存中的旧值淘汰即可。

缺点：会有一次缓存缺失。

**更新Cache**

优点：不会有缓存缺失现象；

缺点：如果更新操作的逻辑复杂，会造成开销过大。另外当不同的线程对同一个数据进行更新时，还会造成数据不一致的现象。

综上，更新cache的消耗更大，且很有可能造成数据的不一致，所以推荐直接淘汰cache。

### 执行的顺序问题

**先淘汰cache，再更新数据库：**

采用同步更新缓存的策略，可能会导致数据长时间不一致，如果用延迟双删来优化，还需要考虑究竟需要延时多长时间的问题——读的效率较高，但数据的一致性需要靠其它手段来保证。

采用异步更新缓存的策略，不会导致数据不一致，但在数据库更新完成之前，都需要到数据库层面去读取数据，读的效率不太好——**保证了数据的一致性，适用于对一致性要求高的业务**。

**先更新数据库，再淘汰cache：**

无论是同步/异步更新缓存，都不会导致数据的最终不一致，在更新数据库期间，cache中的旧数据会被读取，可能会有一段时间的数据不一致，但读的效率很好——**保证了数据读取的效率，如果业务对一致性要求不是很高，这种方案最合适**。

[如何保证缓存(redis)与数据库(MySQL)的一致性](https://developer.aliyun.com/article/712285)

# MySQL

## 1、MyISAM和InnoDB区别

![image-20201120101618173](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201120101618173.png)

## 2、聚族索引和非聚族索引

 innodb 引擎默认会在主键上建立聚族索引（主键索引），就是把行数据和主键放在一起，不需要额外的io。

非聚族索引（辅助索引），和聚集索引相比，叶子节点中不包含行记录的全部数据，只保存指向行数据的地址。

## 3、索引优化

1. 独立的列

   在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

   例如下面的查询不能使用 actor_id 列的索引：

   ```sql
   SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
   ```

2. 多列索引

   在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

   ```sql
   SELECT film_id, actor_ id FROM sakila.film_actor
   WHERE actor_id = 1 AND film_id = 1;
   ```

3. 索引列的顺序

   让选择性最强的索引列放在前面。

   索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

4. 前缀索引

   对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

   前缀长度的选取需要根据索引选择性来确定。

5. 覆盖索引

   索引包含所有需要查询的字段的值。

   具有以下优点：

   - 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
   - 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
   - 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 4、存储架构

![image-20201102161649310](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201102161649310.png)

> SQL语句的执行过程：
>
> 1. 缓存
> 2. 解析器
> 3. 优化器
> 4. 存储引擎

## 5、事务的并发一致性问题

1. 丢失修改
2. 读脏数据
3. 不可重复读
4. 幻读

## 6、事务的隔离级别

- 可串行化（SERIALIZABLE）：通常保证可串行化调度
- 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。
- 已提交读（READ COMMITTED）：只允许读取已提交数据，但不要求可重复读。
- 未提交读（READ UNCOMMITTED）：允许读取未提交数据。

![image-20201119174648073](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119174648073.png)

## 7、MVCC

MVCC==用于实现已提交读和可重复读这两种隔离级别==。

 MVCC 利用了多版本的思想，==写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 `CopyOnWrite` 类似==。

MVCC 的多版本指的是多个版本的快照，**快照存储在 Undo 日志中**，该日志通过回滚指针 `ROLL_PTR` 把一个数据行的所有快照连接起来。

![image-20201119194443983](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119194443983.png)

## 8、索引失效问题



## 9、explain

使用 `explain` 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

`explain` 语法：`explain select * from table where type=1`。

## 10、数据库三大范式

1NF 是对属性的**原子性**，要求属性具有原子性，不可再分解：

> 表：字段1、字段2（字段2.1、字段2.2）、字段3，这个表的字段2还可以分，因此不是1NF。

2NF 是对记录的唯一性，要求记录有唯一性，即实体的唯一性，不存在部分依赖：

> 表：学号、课程号、姓名、学分，这个表的学分依赖课程号，姓名依赖学号，所有不符合2NF。

可能会存在问题：

- 数据冗余；
- 删除异常；
- 插入异常；
- 更新异常；

3NF 是对字段的冗余性，要求任何字段不能由其他字段派生出来，要求字段没有冗余；

> 表：学号、姓名、年龄、学院名称、学员电话，这个表存在**依赖传递**: (学号) → (学生)→(所在学院) → (学院电话) 。

**可能会存在问题：**

- `数据冗余:`有重复值；
- `更新异常：`有重复的冗余信息，修改时需要同时修改多条记录，否则会出现**数据不一致的情况** 。

## 11、SQL优化，有遇见过慢SQL吗

- 正确的使用索引
- 不要使用 select *；
- 排序请尽量使用升序 ;
- 调整索引列的顺序，把选择性强的放前面
- 尽量规避大事务的 SQL
- 分页语句 limit 的问题
- 不让 mysql 干多余的事情，如计算；

## 12、redo log、undo log、binlog

**redo log：**

- 确保事务的持久性；

**undo log：**

- 提供了MVCC下的读，保存了一个数据的多个版本快照，通过回滚指针把一个数据行的多个版本连接起来。

**binlog：**

- 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。

# Spring/Spring MVC

## 1、为什么要使用Spring

1. Spring是一个轻量级的DI和AOP容器与框架。
2. 用Spring的**DI**（Dependency Injection，依赖注入），降低组件耦合；
3. 用Spring的AOP，权限检查、日志、监控、事务方面很友好等。
4. 但Spring不支持分布式。
5. Spring不仅是Spring，而是一个生态，许多我们常用的功能都可以配合到Spring中来使用，比如使用redis，各种ORM框架等。

## 2、解释一下IOC

控制反转：相比传统设计方法中对象之间的高耦合关联关系，IoC将对象之间的关联任务交由装配器负责绑定和实例化，而这个过程是通过依赖注入（DI）实现的。依赖注入有三种方式：

- 构造器注入；
- Setter方法注入；

## 3、解释一下AOP

1. `连接点`：类里面哪些方法可以被增强，这些方法称为连接点。
2. `切入点（PointCut）`：实际中被真正增强的方法，称为切入点。
3. `通知（增强）（Advice）`
   1. 实际增强的逻辑部分称为通知；
   2. 通知的类型有：==前置通知、后置通知、环绕通知、异常通知、最终通知==

4. `切面`：是一个动作，是把通知应用到切入点的过程。

## 4、Filter、Interceptor、AOP的区别

|             | 可获取参数                                              | 说明                                                         |
| ----------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| Filter      | ServletRequest、ServletResponse、FilterChain            | 可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息 |
| Interceptor | HttpServletRequest、HttpServletResponse、Object handler | 可以拿到你请求的控制器和方法，却拿不到请求方法的参数         |
| AOP         | ProceedingJoinPoint                                     | 可以拿到方法的参数，但是却拿不到http请求和响应的对象         |

拦截器执行的顺序：

![image-20210301172058251](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301172058251.png)

[filter、interceptor、aop实现与区别](https://blog.csdn.net/FU250/article/details/80292293)

## 5、Spring有哪些主要模块

![](https://gitee.com/yanjundong97/picBed/raw/master/images/Spring结构.png)

## 6、Spring如何解决循环依赖

spring对循环依赖的处理有三种情况：

- 构造器的循环依赖：spring处理不了，直接抛出 `BeanCurrentlylnCreationException` 异常。
- 单例模式下 setter 循环依赖：通过 `三级缓存` 处理。
- 非单例循环依赖：无法处理。

> Spring并不是只能解决setter方法的循环依赖：
>
> ![image-20210301175801797](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301175801797.png)

Spring在创建Bean的过程中分为三步：

1. 实例化，对应方法：`AbstractAutowireCapableBeanFactory`中的`createBeanInstance`方法
2. 属性注入，对应方法：`AbstractAutowireCapableBeanFactory`的`populateBean`方法
3. 初始化，对应方法：`AbstractAutowireCapableBeanFactory`的`initializeBean`

三级缓存：

1. `singletonObjects`，一级缓存，存储的是所有创建好了的单例Bean
2. `earlySingletonObjects`，完成实例化，但是还未进行属性注入及初始化的对象
3. `singletonFactories`，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDcwNjEzMzAxODY2OS5wbmc?x-oss-process=image/format,png)

[Spring如何解决循环依赖](https://developer.aliyun.com/article/766880)

## 7、Spring 中的 bean 是线程安全吗

==Spring框架并没有对单例bean进行任何多线程的封装处理==。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态（比如Service类和DAO类），所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。

最浅显的解决办法就是==将bean的作用域由`singleton`变更为`prototype`==。

在Spring的Bean配置中，存在这样两种情况：

  ```xml
<bean  id="testManager" class="com.sw.TestManagerImpl"  scope="singleton" />   
<bean  id="testManager" class="com.sw.TestManagerImpl"  scope="prototype" />  
  ```

- Singleton表示该bean全局只有一个实例，Spring中bean的scope默认是singleton；
- Prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的bean。

在SSH架构中，一般用的都是singleton，Bean的注入由Spring管理。

如果一个有状态的bean，被配置为singleton，则存在资源共享问题，而如果是prototype的话，就不会出现资源共享问题。

为了解决这个矛盾，所以我们在编程时，应该：

- 尽量使用无状态bean；
- 如果在程序中出现私有变量，尽量替换为参数；
- 对于访问私有变量的方法可以增加变量传入或者通过ThreadLocal来获取。

## 8、Spring的bean支持的作用域

| 类别          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| Singleton     | 单例模式，在Spring IoC容器中仅存在一个bean实例，，整个IoC容器方位内都能共享该实例，是所有bean的默认作用域。**性能更高，但存在竞争访问**（其实只要Controller中不定义属性，那么单例模式是安全的） |
| Prototype     | 原型模式，容器无法完成依赖注入，每次通过容器的getBean方法获取prototype定义的bean，都将产生一个新的bean实例，创建后容器将不对其管理。时间空间耗费成本高，但不存在资源共享问题。 |
| Request       | 在Web应用中，对于每一次HTTP请求，使用request定义的bean都将产生一个新的实例，和prototype不同的是，创建后，Spring依然会监听。 |
| Session       | 在Web应用中，每次会话，同上。                                |
| globalSession | 在Web应用中，全局的web域，类似于servlet中的application。     |

## 9、Spring 自动装配 bean 的方式？

1. 基于XML的配置；

2. 基于注解的配置

   - `@Autowired`：根据属性类型进行自动装配

   - `@Qualifier`：根据属性名称进行注入 ，和上面的 @Autowired 一起使用

     如果 `UserDao` 这个接口有多个实现类，那使用 `@Autowired` 时根据类型注入就不知道使用哪个类型去注入属性，但是可以使用 `@Qualifier` 指定 bean 的名称来注入。

   - `@Resource`：可以根据类型或名称注入
   - `@Value`：注入普通属性类型

3. 基于Java的配置（Spring对Java配置的支持是由 `@Configuration` 注解和 `@Bean` 注解来实现的）

## 10、Spring的启动过程



## 11、bean的生命周期

bean的生命周期有七步：

1. 通过构造器创建 bean 实例（无参数构造）
2. 为 bean 的属性设置值和对其他 bean 的引用（调用 `setter` 方法）
3. **把bean实例传递给后置处理器中的 `postProcessBeforeInitialization` 方法**
4. 调用 bean 的初始化的方法（需要进行配置初始化的方`init`方法） 
5. **把bean实例传递给后置处理器中的 `postProcessAfterInitialization` 方法**
6. bean 可以使用了（对象获取到了）
7. 当容器关闭的时候，调用 bean 销毁的方法（需要进行配置销毁的`destory`方法）

## 12、ApplicationContext和BeanFactory

## 12、BeanFactory和FactoryBean

用户在使用容器时，可以使用转义符 `&` 来得到 `FactoryBean` 本身，用来区分通过容器来获取 `FactoryBean` 产生的对象和获取 `FactoryBean` 本身。【`FactoryBean` 是一个 `Bean`，`BeanFactory` 是IOC容器】。举例来说，如果 `myJndiObject` 是一个 `FactoryBean`，那么使用 `&myJndiObject` 得到的是 `FactoryBean` ，而不是 `myJndiObject` 这个 `FactoryBean` 产生出来的对象。

![](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201112201729086.png)

在 `Spring`中，所有的 bean 都是由 `BeanFactory ` 来进行管理的，但对于 `FactoryBean` 而言，这个 `Bean` 不是一个简单的 `Bean`，而是一个能够产生或者修饰对象生成的工厂 `Bean`，它的实现与设计模式中的工厂模式和修饰器模式类似。

### FactoryBean接口

**使用FactoryBean的好处：**一般情况下，Spring通过反射机制利用`<bean>`的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在`<bean>`中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个`org.springframework.bean.factory.FactoryBean`的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。

例子：如果使用传统方式配置下面Car的`<bean>`时，Car的每个属性分别对应一个`<property>`元素标签。

```java
package com.coder.ioc;

public class Car {
    private int maxSpeed;
    private String brand;
    private double price;

    public int getMaxSpeed() {
        return this.maxSpeed;
    }

    public void setMaxSpeed(int maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public String getBrand() {
        return this.brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public double getPrice() {
        return this.price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
```

如果用`FactoryBean`的方式实现就灵活点，下例通过逗号分割符的方式一次性的为Car的所有属性指定配置值：

```java
package com.coder.ioc;

import org.springframework.beans.factory.FactoryBean;

public class CarFactoryBean implements FactoryBean<Car> {
    private String carInfo;

    public Car getObject() throws Exception {
        Car car = new Car();
        String[] infos = carInfo.split(",");
        car.setBrand(infos[0]);
        car.setMaxSpeed(Integer.valueOf(infos[1]));
        car.setPrice(Double.valueOf(infos[2]));
        return car;
    }

    public Class<Car> getObjectType() {
        return Car.class;
    }

    public boolean isSingleton() {
        return false;
    }

    public String getCarInfo() {
        return this.carInfo;
    }

    // 接受逗号分割符设置属性信息
    public void setCarInfo(String carInfo) {
        this.carInfo = carInfo;
    }
}
```

有了这个`CarFactoryBean`后，就可以在配置文件中使用下面这种自定义的配置方式配置CarBean了：

```xml
<bean id="car" class="com.coder.ioc.CarFactoryBean">
    <property name="carInfo" value="法拉利,400,2000000" />
</bean>
```

当调用 `getBean("car")` 时，Spring通过反射机制发现`CarFactoryBean`实现了`FactoryBean`的接口，这时Spring容器就调用接口方法`CarFactoryBean#getObject()`方法返回。如果希望获取`CarFactoryBean`的实例，则需要在使用`getBean(beanName)`方法时在`beanName`前显示的加上`&`前缀：如`getBean("&car")`; 

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        CarFactoryBean carFactoryBean = (CarFactoryBean) context.getBean("&car");
        Car car = (Car) context.getBean("car");
        System.out.println(carFactoryBean.getCarInfo());
        System.out.println(car);
    }
}
```

[BeanFactory和FactoryBean的区别](https://www.cnblogs.com/aspirant/p/9082858.html)

## 13、Spring事务的隔离级别

Spring的事务隔离和数据库的事务隔离级别相关。

|                  | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | 有   | 有         | 有   |
| Read committed   | 无   | 有         | 有   |
| Repeatable read  | 无   | 无         | 有   |
| Serializable     | 无   | 无         | 无   |

1. `read uncommited`：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。

2. `read commited`：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。

3. `repeatable read`：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。

4. `serializable`：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。

5. 脏读、不可重复读、幻象读概念说明：

   - 脏读：指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。

     <img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164556628.png" alt="image-20201119164556628" style="zoom: 50%;" />

   - 不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。

     <img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164704083.png" alt="image-20201119164704083" style="zoom:50%;" />

   - 幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）

     <img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201119164757052.png" alt="image-20201119164757052" style="zoom:50%;" />

## 14、Spring事务的传播行为

![image-20201004223919417](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201004223919417.png)

## 15、Spring MVC运行流程

![image-20210301210657284](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301210657284.png)

1. 首先浏览器发送请求——>`DispatcherServlet`，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；
2. `DispatcherServlet`——>`HandlerMapping`，处理器映射器将会把请求映射为`HandlerExecutionChain`对象（包含一个`Handler`处理器对象、多个`HandlerInterceptor`拦截器）对象；
3. `DispatcherServlet`——>`HandlerAdapter`，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；
4. `HandlerAdapter`——>调用处理器相应功能处理方法，并返回一个`ModelAndView`对象（包含模型数据、逻辑视图名）；
5. `ModelAndView`对象（`Model`部分是业务对象返回的模型数据，`View`部分为逻辑视图名）——> `ViewResolver`， 视图解析器将把逻辑视图名解析为具体的View；
6. `View`——>渲染，View会根据传进来的Model模型数据进行渲染，此处的 `Model` 实际是一个`Map`数据结构；
7. 返回控制权给`DispatcherServlet`，由`DispatcherServlet`返回响应给用户，到此一个流程结束。

## 16、Spring MVC有哪些组件？

1. `DispatcherServlet`：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现。
2. `HandlerMapping`：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现
3. `Handler`：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。
4. `HandlAdapter`：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。
5. `ModelAndView`是springmvc的封装对象，将model和view封装在一起。
6. `ViewResolver`：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。
7. `View`：是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。

`DispatcherServlet` 类中有9个引用类型的属性，

SpringMVC在工作的时候，关键位置都是由这些组件完成的。

共同点：九大组件全部都是接口

```java
/** MultipartResolver used by this servlet. */
/** 文件上传解析器 */
@Nullable
private MultipartResolver multipartResolver;

/** LocaleResolver used by this servlet. */
/** 区域信息解析器，和国际化有关 */
@Nullable
private LocaleResolver localeResolver;

/** ThemeResolver used by this servlet. */
/** 主题解析器 */
@Nullable
private ThemeResolver themeResolver;

/** List of HandlerMappings used by this servlet. */
/** Handler映射信息 */
@Nullable
private List<HandlerMapping> handlerMappings;

/** List of HandlerAdapters used by this servlet. */
/** Handler的适配器 */
@Nullable
private List<HandlerAdapter> handlerAdapters;

/** List of HandlerExceptionResolvers used by this servlet. */
/** SpringMVC强大的异常解析功能，异常解析器 */
@Nullable
private List<HandlerExceptionResolver> handlerExceptionResolvers;

/** RequestToViewNameTranslator used by this servlet. */
@Nullable
private RequestToViewNameTranslator viewNameTranslator;

/** FlashMapManager used by this servlet. */
/** SpringMVC 中允许重定向携带数据的功能 */
@Nullable
private FlashMapManager flashMapManager;

/** List of ViewResolvers used by this servlet. */
/** 视图解析器 */
@Nullable
private List<ViewResolver> viewResolvers;
```

> 九大组件的初始化

![image-20201028162425468](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20201028162425468.png)

## 17、`@RequestMapping` 的作用

`@RequestMapping` 是一个用来处理请求地址映射的注解，可用于类或者方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

# SpringBoot

## 1、SpringBoot与Spring的区别

`Spring Boot`是对`Spring`框架的扩展，它消除了设置`Spring`应用程序所需的`XML配置`，为更快，更高效的开发生态系统铺平了道路。

**`Spring Boot`中的一些特征：**

1. 创建独立的`Spring`应用。
2. 嵌入式`Tomcat`、`Jetty`、 `Undertow`容器（无需部署war文件）。
3. 提供的`starters` 简化构建配置
4. 尽可能自动配置`spring`应用。
5. 提供生产指标,例如指标、健壮检查和外部化配置
6. 完全没有代码生成和`XML`配置要求

## 2、SpringBoot的自动装配

`@SpringBootApplication` 包含几个重要的注解：

- `@Configuration`(`@SpringBootConfiguration`实质就是一个`@Configuration`）
- `@EnableAutoConfiguration`，代表开启springboot的自动装配，用作**bean的装配与加载**
- `@ComponentScan`，扫描包，用作**bean的发现**（此处扫描当前main下面app的所在包及其下属包）

# SpringCloud

![image-20210313115312597](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210313115312597.png)

# MyBatis

## 1、什么是MyBatis

1. Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时 只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性 能，灵活度高。
2. MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数 据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
3. 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最 后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返 回 result 的过程）。

## 2、MyBatis的优缺点

**优点：**

1. 基于 SQL 语句编程，相当灵活；提供XML标签，编写动态SQL语句，并可重用。
2. 消除了 JDBC 大量冗余的代码，不 需要手动开关连接，减少了代码量；
3. 很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。
4. 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。
5. 能够与 Spring 很好的集成；

**缺点：**

1. SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。
2. SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

## 3、MyBatis 与 Hibernate 的区别

- Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要 程序员自己编写 Sql 语句
- 

## 4、`#{}` 和 `${}` 的区别

1. `#{}`是预编译处理，`${}`是字符串替换。
2. Mybatis 在处理`#{}`时，会将 sql 中的`#{}`替换为`?`，调用 `PreparedStatement` 的 set 方法来赋值；
3. Mybatis 在处理`${}`时，就是把 `${}` 替换成变量的值。
4. 使用`#{}`可以有效的防止 SQL 注入，提高系统安全性。

## 5、如何处理实体类中的属性名和表中的字段名不同

第 1 种：通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类 的属性名一致

```xml
<select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”>
    select order_id id, order_no orderno ,order_price price form
    orders where order_id=#{id};
</select>
```

第 2 种：通过来映射字段名和实体类属性名的一一对应的关系。

```xml
<resultMap type=”me.gacl.domain.order” id=”orderresultmap”>
    <!–用 id 属性来映射主键字段–>
    <id property=”id” column=”order_id”>
    <!–用 result 属性来映射非主键字段，property 为实体类属性名，column
            为数据表中的属性–>
    <result property = “orderno” column =”order_no”/>
    <result property=”price” column=”order_price” />
</reslutMap>
    
<select id="getOrder" parameterType="int"  resultMap="orderresultmap">
    select * from orders where order_id=#{id}
</select>
```

## 6、Mapper接口的工作原理

Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。

Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 `MapperStatement`。在 Mybatis 中，每一个 `<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MapperStatement` 对象。

举例：`com.mybatis3.mappers.StudentDao.findStudentById`，可以唯一找到 `namespace` 为`com.mybatis3.mappers.StudentDao` 下面 id 为`findStudentById` 的 `MapperStatement`。

Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是 ==JDK 动态代理==，Mybatis 运行时会使用 JDK动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 `MapperStatement` 所代表的 sql，然后将 sql 执行结果返回。

## 7、MyBatis的动态SQL

Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理 是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。

Mybatis 提供了 9 种动态 sql 标签：`trim | where | set | foreach | if | choose | when | otherwise | bind`。

## 8、MyBatis是否支持延迟加载

## 9、MyBatis的一级、二级缓存

1）一级缓存: 基于 `PerpetualCache` 的 `HashMap` 本地缓存，其存储作用域为 `Session`，当 `Session flush` 或 close 之后，该 `Session` 中的所有 Cache 就 将清空，默认打开一级缓存。

2）二级缓存与一级缓存其机制相同，默认也是采用 `PerpetualCache`，`HashMap`存储，不同在于其存储作用域为 `Mapper(Namespace)`，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 `Serializable` 序列化接口(可用来保存对象的状态),可在它的映射文件中配置；

3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

4）默认情况下，缓存会使用最近最少使用算法（LRU）来清除不需要的缓存。

# 操作系统

## 宏内核和微内核

### 1. 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

![image-20210223173822488](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223173822488.png)

## 进程管理

### 进程与线程

- 进程是资源分配的基本单位；
- 线程是处理器调度的基本单位；
- 一个进程可以有多个线程，多个线程共享进程所拥有的资源，在进程挂掉后线程也会销毁；
- 创建和销毁进程的开销比线程的开销大，因为创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- 线程间的通信更加容易，可以直接读写同一进程中的数据进行通信。

### 进程的状态切换

![image-20210223174630373](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223174630373.png)

- 只有就绪态（ready）和运行态（running）可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态（waiting）是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

### 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

#### 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

1. **先来先服务 first-come first-serverd**，有利于长作业，但不利于短作业。
2. **短作业优先 shortest job first**，长作业有可能会饿死。
3. **最短剩余时间优先 shortest remaining time next**，按剩余运行时间的顺序进行调度。

#### 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

1. **时间片轮转**

2. **优先级调度**，为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

3. **多级反馈队列**，`多级队列`设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

   ![image-20210223192059536](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223192059536.png)

#### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### 进程同步

#### 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

#### 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

#### 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

如果信号量只能取值0和1，那么就是互斥量；如果允许是>=0的值，可以用来实现生产者和消费者。

#### 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

### 进程间通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

#### 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

![image-20210223194035692](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223194035692.png)

#### FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223194139410.png" alt="image-20210223194139410" style="zoom:67%;" />

#### 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

#### 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

#### 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

#### 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 父进程如何知道子进程结束



## 死锁问题

### 产生的必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

### 鸵鸟策略

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

### 死锁预防

在程序运行之前预防发生死锁。

#### 1、破坏互斥条件

例如脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

#### 2、破坏占有和等待条件

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

#### 3、破坏不可抢占条件

#### 4、破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。

### 死锁避免

在程序运行时避免发生死锁。

#### 安全状态

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223195606949.png" alt="image-20210223195606949" style="zoom:80%;" />

#### 银行家算法

主要是看 使用手中的资源 是否能把每一个进程执行完。

## 内存管理

### 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

每个程序都有自己的地址空间，这些地址空间被分割成固定大小的块，被称为页。这些页会被映射到物理内存，但是不需要映射到连续的物理内存，也不需要全部块实际在物理内存中，允许一部分块位于磁盘中，在需要时再置换到内存中【如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。】。这使得有限的内存运行大程序成为可能。

![image-20210223213920034](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223213920034.png)

### 分页系统地址映射

虚拟地址 ---> 物理地址

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223214450568.png" alt="image-20210223214450568" style="zoom:80%;" />

### 页面置换算法

1. 最佳
2. 最近最久未使用，最接近最佳算法，但实现较困难。
3. 先进先出
4. 时钟置换算法

### 分段

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

### 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

### 分段与分页的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

## 设备管理

### 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

#### 1、先来先服务

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

#### 2、最短寻道时间优先

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223220427686.png" alt="image-20210223220427686" style="zoom:80%;" />

#### 3、电梯算法

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 `最短寻道时间优先` 的饥饿问题。

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210223220546813.png" alt="image-20210223220546813" style="zoom:80%;" />

## 链接

### 编译系统

以下是一个 hello.c 程序：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.c
```

这个过程大致如下：

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg)



- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 `printf.o` 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

### 静态链接

### 目标文件

### 动态链接

# 计算机网络

## 网络模型

![image-20210224180711690](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210224180711690.png)

1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率
   等。 它的主要作用是传输比特流（就是由 1、 0 转化为电流强弱来进行传输,到达目的地后在转化为
   1、 0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
2. 数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这
   一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
3. 网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工
   作的设备是路由器，常把这一层的数据叫做数据包。
4. 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如： TCP（传输控制协议，
   传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）， UDP（用户数据报协议，
   与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这
   种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。
   常常把这一层数据叫做段。
5. 会话层：通过传输层（端口号：传输端口与接收端口） 建立数据传输的通路。主要在你的系统之间
   发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
6. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够
   识别的东西转换成人能够能识别的东西（如图片、声音等））
7. 应用层：主要是一些终端的应用，比如说FTP（各种文件下载）， WEB（IE浏览）， QQ之类的（你
   就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。

## HTTP

### HTTP的特点

​	1.简单快速、灵活

​	2.无连接：每一次连接只处理一个请求，服务器在处理挽清秋并收到应答后会断开连接；

​	3.无状态：服务器对传递内容没有记忆。

### HTTP报文

1. 请求报文：由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。 

   ![image-20210224181036405](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210224181036405.png)

   **请求行**数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用**空格**分隔。

2. 响应报文：状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。

   ![image-20210224181143323](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210224181143323.png)



### HTTP请求方法

| 序号 | 方法       | 描述                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | **GET**    | 获取资源                                                     |
| 2    | **POST**   | 传输实体主体                                                 |
| 3    | **HEAD**   | 本质和get一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的时间等。 |
| 4    | **PUT**    | 传输文件，在请求报文的主体中包含文件内容，然后保存到URI的指定位置 |
| 5    | **DELETE** | 删除文件，删除URI指定的文件资源                              |
| 6    | CONNECT    | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 connect的作用就是将服务器作为代理，让服务器代替用户去访问其他网页（说白了，就是翻墙），之后将数据返回给用户。 |
| 7    | OPTIONS    | 用来查询针对请求URI指定资源支持的方法。                      |
| 8    | TRACE      | 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。 |

### HTTP状态码

**1XX 信息**

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应

**2XX 成功**

- **200 OK**：成功
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

**3XX 重定向**

- **301 Moved Permanently** ：永久性重定向，访问的URL已永久发生改变
- **302 Found** ：临时性重定向，访问的URL临时发生了改变
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**4XX 客户端错误**

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**

**5XX 服务端错误**

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **502 Bad Gateway**：网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
- **504 Gateway Time-out**：充当网关或代理的服务器，未及时从远端服务器获取请求

### 持久化连接与管线化方式

**持久连接**

前面我们在说HTTP特点的时候说过，HTTP是一 种无连接，无状态的协议。而TCP是有状态的长连接，为什么HTTP是基于TCP,但HTTP却是无连接?
		因为HTTP每次请求完成后就会关闭TCP协议，但是我们可以通过编程自己控制TCP的关闭时间。由于每次请求都要连接TCP协议，效率很低，所以从HTTP/1.1过后， 就开启了一个keep-Alive来保持连接，但是这个连接也是有时间限制的，不同的服务器有不同的处理，自己也可以设置。

**管线化**
以前请求和响应模式基本是这样的:
请求1->响应1->请求2->响应2。。。
有了管线化过后请:求和响应模式就变成了这样:
请求1->请求2->响应1->响应2。。。
也就是说，现在可以先一次进行很多次请求，而不是像以前那样，只有上一次的响应成功后才可以下一次请求，这样大大的提高了效率。

### get与post请求的区别

1. GET在浏览器回退时是无影响的，而POST会再次提交请求。
2. GET产生的URL地址可以被作为书签，而POST不可以。
3. GET请求会被浏览器缓存，而POST不会，除非手动设置。
4. GET请求只能进行url编码，而POST支持多种编码方式。
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
6. GET请求在URL中传送的参数是有长度限制的，而POST没有。
7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
9. GET参数通过URL传递，POST放在Request body中。
10. 本质上的区别：**GET产生一个TCP数据包；POST产生两个TCP数据包。**
    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### cookies与session

​	cookies数据保存在客户端，session数据保存在服务器端；
​	cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗；
​	session较安全，但占用服务器资源；
​	两者都是在服务端产生；
​	都具有一定的时效性；
​	服务器端产生一个sessionid，通过set-cookie写入sessionid返回响应给客户端。

### HTTPS

​	HTTPS（全称： Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层， HTTPS 的安全基础是 SSL。其所用 的端口号是 443。 过程大致如下：    

建立连接获取证书

 （1） SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握 手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算 法列表和其它一些需要的消息， SSL 的服务器端会回应一个数据包，这里面确定了这次通信所 需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书 的公司，公共秘钥）。

 证书验证 

（2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。

 数据加密和传输 

（3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。  

> HTTPS：客户端和服务器交互
>
> 1. 报文不加密 ——> 使用SSL加密整个通信，对称加密与非对称加密的混合使用
> 2. 不能验证对方身份 ——> 使用证书验证对方身份
> 3. 数据在传输时会被人篡改 ——> 使用MD5加密

### Http 和 Https 的区别

（1）证书申请方式不同：https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用，http免费申请。 

（2）传输安全性不一样： http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议。 

（3）端口号不一样：前者 是 80，后者是 443。 

（4） 连接方式不一样：http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构 建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

## TCP/IP

### 三次握手

​	<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210303112350022.png" alt="image-20210303112350022" style="zoom:80%;" />

#### 1.连接过程

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

#### 2.TCP的状态

- `LISTEN`：等待从任何远端TCP 和端口的连接请求。
- `SYN_SENT`：发送完一个连接请求后等待一个匹配的连接请求。
- `SYN_RECEIVED`：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。
- `ESTABLISHED`：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。

#### 2.三次握手的原因？

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

> 如果只进行两次握手，客户端在超时重传后与服务器建立了连接，但是上一个超时的连接请求迟早会到达服务器，这时候服务器会再次建立连接，浪费了服务器资源。

### 四次挥手

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="四次挥手" style="zoom:67%;" />

#### 1.挥手过程

1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，
然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u
2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。
4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。
首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

#### 2.TCP的状态

- `FIN_WAIT_1`：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。
- `FIN_WAIT_2`：等待远端TCP 的连接终止请求。
- `CLOSE_WAIT`：等待本地用户的连接终止请求。
- `LAST_ACK`：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）
- `TIME_WAIT`：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
- `CLOSED`：不在连接状态（这是为方便描述假想的状态，实际不存在）

#### 3.为什么要四次挥手

​	TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连 接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单 方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个 方向的连接。    

#### 4.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

#### 5.TIME_WAIT状态产生过多的原因

​	每个连接断开都会有time_wait状态产生，大量的短连接建立与关闭则会出现time_wait产生过多。

​	解决方法：

a、修改TIME_WAIT连接状态的上限值
b、启动快速回收机制
c、开启复用机制
d、修改短连接为长连接方式
e、 由客户端来主动断开连接

### TCP首部（20字节）

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210224194337369.png" alt="image-20210224194337369" style="zoom:80%;" />

### UDP首部（8字节）

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210224194409423.png" alt="image-20210224194409423" style="zoom:80%;" />

### tcp 和 udp 的区别

（1） TCP 面向连接，UDP 是无连接的；
（2） TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付；
（3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的， UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）；
（4）每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信；
（5） TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节；
（6） TCP 的逻辑通信信道是全双工的可靠信道， UDP 则是不可靠信道。

### 超时重传和快速重传

​	超时重传：超过一定时间后，重新发送数据包。

​	快速重传：发送端主机连续三次收到同一个ack应答，将会对其所对应的数据进行重发。

### TCP为什么可靠

#### 1. **校验和**

TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验范围包括TCP首部及数据部分，但是UDP的检验和字段为可选的，而TCP中是必须有的。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确（UDP中为0是正确），否则存在错误。

#### 2. 确认应答与序列号

TCP将每个字节的数据都进行了编号，这就是序列号。
 序列号的作用：
 a、保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）
 b、保证数据的按序到达
 c、提高效率，可实现多次发送，一次确认
 d、去除重复数据
 数据传输过程中的确认应答处理、重发控制以及重复控制等功能都可以通过序列号来实现

TCP通过确认应答机制实现可靠的数据传输。在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。

#### 3. 超时重传

当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传）。
 一种情况是发送包丢失了，其基本过程如下：

![img](E:/java%E5%AD%A6%E4%B9%A0/java%E5%AD%A6%E4%B9%A0.assets/5021195-8a5519e715564834.webp) 

发送包丢失导致的超时

另一种情况是ACK 丢失，过程如下：

 ![img](E:/java%E5%AD%A6%E4%B9%A0/java%E5%AD%A6%E4%B9%A0.assets/5021195-b7ed4226d8b189d3.webp) 

ACK 丢失导致的超时

当接收方接收到重复的数据时就将其丢掉，重新发送ACK。而要识别出重复的数据，前面提到的序列号就起作用了。

重传时间的确定：
 重传时间的确定：报文段发出到收到应答中间有一个报文段的往返时间RTT，显然超时重传时间RTO会略大于这个RTT，TCP会根据网络情况动态的计算RTT，即RTO是不断变化的。在Linux中，超时以500ms为单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。其规律为：如果重发一次仍得不到应答，就等待2*500ms后再进行重传，如果仍然得不到应答就等待4*500ms后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP认为网络或对端主机出现异常，就会强行关闭连接。

#### 4. 连接管理

连接管理机制即TCP建立连接时的三次握手和断开连接时的四次挥手。

#### 5. 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

#### 6. 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png)

##### 6.1慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

##### 6.2 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，==如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行`快重传`==，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

==在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行`快恢复`，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。==

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

### IP头部（20字节）

<img src="https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210225120534109.png" style="zoom:67%;" />

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 浏览器发起请求到收到响应的过程

（ 1）域名解析，找出对端服务器 IP 地址
（ 2） TCP 请求（三次握手）
（ 3）发送 HTTP 请求
（ 4）接收 HTTP 响应
（ 5）解析渲染服务器端的响应数据
（ 6）断开 TCP 连接

参考：[URL从输入到页面展示发生了什么？](https://segmentfault.com/a/1190000017184701)

## DNS解析过程

DNS解析的方法包括2种：

1. 递归查询

   ![image-20210313233141478](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210313233141478.png)

2. 迭代查询

   ![image-20210225121552093](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210225121552093.png)

在实际中，为了加快DNS的解析过程，会在客户端和服务端加入缓存机制。当我们在浏览器中输入一个网站时，会发生如下过程：

1. 浏览器中输入想要访问的网站的域名，操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
2. 如果hosts里没有这个域名的映射，客户端会向本地DNS服务器发起查询。本地DNS服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。
3. 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。

![image-20210225122041303](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210225122041303.png)

## ip地址的ABCD类是怎样分的

（1）A类地址的表示范围是：0.0.0.0-127.255.255.255，默认网络掩码为：255.0.0.0，A类地址分配给规模特别大的网络使用。

（2）B类地址表示范围是：128.0.0.0-191.255.255.255，默认网络掩码为欸：255.255.0.0，B类地址分配给一般的中型网络。

（3）C类地址的表示范围是192.0.0.0-223.255.255.255，默认网络掩码是：255.255.255.0，C类地址分配给小型网络，如局域网。

（4）D类地址称为广播地址，提供特殊协议向选定的节点发送信息使用。

# Linux

## 1、命令

### top

![image-20210325093747908](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210325093747908.png)

### 管道

```sh
ps -ef | grep java
ls | grep pmem
```



# 设计模式

## 1、单例模式

```java
/**
 * 懒汉式单例
 */
public class singleton1 {
    private static singleton1 signleton = null;
    private static Object lock = new Object();

    private singleton1() {}

    public static singleton1 getInstance() {
        if (signleton == null) { //双重锁定
            synchronized (lock) {
                if (signleton == null) {
                    signleton = new singleton1();
                }
            }
        }

        return signleton;
    }
}
```

```java
/**
 * 饿汉式单例
 */
public final class singleton2 {
    private static final singleton2 instance = new singleton2();

    private singleton2() {}

    public static singleton2 getInstance() {
        return instance;
    }
}
```

## 2、工厂模式

## 3、抽象工厂

## 4、装饰模式

## 5、建造模式

## 6、适配器模式

# 数据结构

## 排序

### 直接插入排序

在前面的有序序列中找到第i元素的位置，然后插入。

![image-20210301153051821](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301153051821.png)

```java
    /**
     * 直接插入排序
     */
    public static void insertSort(int[] A) {
        int temp = 0;
        int i = 0, j = 0;
        for (i = 1; i < A.length; i++) {
            temp = A[i];
            for (j = i - 1; A[j] > temp && j >= 0; j--) {
                A[j + 1] = A[j];
            }
            A[j + 1] = temp;
        }
    }
```

### 冒泡排序

```java
    /**
     * 冒泡排序
     */
    public static void bubbleSort(int[] A) {
        int i = 0, j = 0;
        int temp = 0;
        for (i = 0; i < A.length - 1; i++) {
            for (j = A.length - 1; j > i; j--) {
                if (A[j] < A[j - 1]) {
                    // swap(A[j], A[j-1])
                    temp = A[j];
                    A[j] = A[j - 1];
                    A[j - 1] = temp;
                }
            }
        }
    }
```

### 快速排序

```java
    /**
     * 快速排序
     */
    public static void quickSort(int[] A, int low, int high) {
        if (low < high) {
            int partition = partition(A, low, high);
            quickSort(A, low, partition - 1);
            quickSort(A, partition + 1, high);
        }
    }

    private static int partition(int[] A, int low, int high) {
        int temp = A[low];

        while (low < high) {
            while (low < high && A[high] >= temp) --high;
            A[low] = A[high];
            while (low < high && A[low] <= temp) ++low;
            A[high] = A[low];
        }
        A[low] = temp;

        return low;
    }

```

### 选择排序

在第二部分（`i~n-1`）中找到最小的元素，然后放在 i 位置。

![image-20210301154732531](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301154732531.png)

```java
    /**
     * 选择排序
     */
    public static void selectSort(int[] A) {
        int i = 0, j = 0;
        int min = 0;
        int temp = 0;
        for (i = 0; i < A.length - 1; i++) {
            for (j = i, min = i; j < A.length; j++) {
                if (A[j] < A[min]) {
                    min = j;
                }
            }
            // swap(A[min], A[i])
            temp = A[min];
            A[min] = A[i];
            A[i] = temp;
        }
    }
```

### 堆排序

先建立大顶堆，完成后，根节点为最大值。然后与堆底元素交换，重新调整，如此重复，直到剩下一个元素为止。

![image-20210301155852693](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301155852693.png)

```java
    /**
     * 堆排序算法
     */
    // 建堆
    public static void buildMaxHeap(int[] A, int len) {
        for (int i = len / 2; i >= 0; --i)  // 从 i=[n/2]~1，反复调整堆
            adjustDown(A, i, len);
    }

    // 向下调整
    private static void adjustDown(int[] A, int k, int len) {
        int temp = A[k];
        for (int i = 2 * k; i < len; i = i * 2) {
            if (i < len && A[i] < A[i + 1])
                i++;
            if (temp >= A[i])
                break;
            else {
                A[k] = A[i];
                k = i;	// 修改k值，以便继续向下筛选
            }
        }
        A[k] = temp;
    }

    public static void heapSort(int[] A) {
        int len = A.length;
        buildMaxHeap(A, len);   // 初始建堆
        for (int i = len-1; i > 0; i--) {
            swap(A, i, 0);
            adjustDown(A, 0, i-1);
        }
    }
```



### 归并排序

```java
/**
     * 归并排序算法
     */
public static void mergeSort(int[] A, int low, int high) {
    if (low < high) {
        int mid = (low + high) >> 1;    // 从中间划分两个子序列
        mergeSort(A, low, mid);
        mergeSort(A, mid + 1, high);
        merge(A, low, mid, high);   // 归并
    }
}

private static void merge(int[] A, int low, int mid, int high) {
    // 辅助数组
    int[] B = new int[A.length];
    for (int i = low; i <= high; i++) {
        B[i] = A[i];
    }
    int index = low, i, j;
    for (i = low, j = mid + 1; i <= mid && j <= high; ) {
        if (B[i] <= B[j]) {
            A[index++] = B[i++];
        } else {
            A[index++] = B[j++];
        }
    }
    while (i <= mid) A[index++] = B[i++];   // 若第一个表未检测完，复制
    while (j <= high) A[index++] = B[j++];  // 若第二个表未检测完，复制
}
```



### 比较

![image-20210301155045051](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210301155045051.png)

## 二叉树

### 递归遍历

```java
/** 递归先序遍历 */
public static void preOrderPrint(Node root) {
    if (root == null) {
        return;
    }
    System.out.print(root.val + " ");
    preOrderPrint(root.left);
    preOrderPrint(root.right);
}

/** 递归中序遍历 */
public static void inOrderPrint(Node root) {
    if (root == null) {
        return;
    }
    preOrderPrint(root.left);
    System.out.print(root.val + " ");
    preOrderPrint(root.right);
}

/** 递归后序遍历 */
public static void PostOrderPrint(Node root) {
    if (root == null) {
        return;
    }
    preOrderPrint(root.left);
    preOrderPrint(root.right);
    System.out.print(root.val + " ");
}
```

### 非递归遍历

```java
/** 非递归先序遍历 */
public static void preOrderPrintWithStack(Node root) {
    Stack<Node> stack = new Stack<>();
    Node node = root;
    while (null != node || !stack.isEmpty()) {
        while (node != null) {
            System.out.print(node.val + " ");
            stack.push(node);
            node = node.left;
        }
        if (!stack.isEmpty()) {
            node = stack.pop();
            node = node.right;
        }
    }
}

/** 非递归中序遍历 */
public static void inOrderPrintWithStack(Node root) {
    Stack<Node> stack = new Stack<>();
    Node node = root;
    while (node != null || !stack.isEmpty()) {
        while (node!= null) {
            stack.push(node);
            node = node.left;
        }
        if (!stack.isEmpty()) {
            node = stack.pop();
            System.out.print(node.val + " ");
            node = node.right;
        }
    }
}

/** 非递归后序遍历 */
public static void postOrderPrintWithStack(Node root) {

}
```

### 获取指定节点的搜索路径

```java
/** 递归指定节点的搜索路径 */
public static void searchRoute(Node root, Node node, List<Node> route) {
    if(root == null) {
        return;
    }

    route.add(root);
    searchRoute(root.left, node, route);
    searchRoute(root.right, node, route);

    if (route.get(route.size()-1).val == node.val) {
        return;
    } else {
        route.remove(route.size() - 1);
    }
}
```

> 如果是二叉搜索树的话，会更为简单。

## LeetCode

### dfs-字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

[字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

```java
public class Solution {
    private Set<String> set = new HashSet<>();
    public String[] permutation(String s) {
        char[] c = s.toCharArray();
        boolean[] visit = new boolean[c.length];
        char[] res = new char[c.length];
        dfs(c, res, visit, 0);

        return set.toArray(new String[set.size()]);
    }
    
    // dfs
    private void dfs(char[] c, char[] res, boolean[] visit, int index) {
        if(index >= c.length) {
            set.add(new String(res));
            return;
        }
        for(int i = 0; i < c.length; ++i) {
            if(!visit[i]) {
                visit[i] = true;
                res[index] = c[i];
                dfs(c, res, visit, index+1);
                visit[i] = false;   // 剪枝
            }
        }
    }
}
```

### 摩尔投票法-出现次数超一半的数

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

[数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

```java
class Solution {
   public int majorityElement(int[] nums) {
        int x = 0, votes = 0;
        for(int num : nums) {
            if(votes == 0) 
                x = num;
            votes = votes + ((x == num) ? 1 : -1);
        }
        return x;
    }
}
```

### 动态规划-连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

[连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1] + nums[i] , nums[i]);
            max = Math.max(dp[i], max);
        }
        return max;
    }
}
```

> 动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。

其他动态规划的题：

- [把数字翻译为字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

### 动态规划-三指针-丑数

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

```java
public int nthUglyNumber(int n) {
    int[] dp = new int[n];

    dp[0] = 1;
    int a = 0, b = 0, c = 0;
    int d0, d1, d2;
    for (int i = 1; i < n; i++) {
        d0 = dp[a] * 2;
        d1 = dp[b] * 3;
        d2 = dp[c] * 5;
        dp[i] = Math.min(Math.min(d0,d1), d2);
        // 如果和dp[i] 相等，指针就需要 + 1
        if (dp[i] == d0)
            a++;
        if (dp[i] == d1)
            b++;
        if (dp[i] == d2)
            c++;
    }
    return dp[n-1];
}
```



# 分布式

## 1、CAP定理

- `Consistensy`（一致性）：不同节点上数据的强一致性

- `Partition Tolerance`（割断容忍性）：允许部分节点与其他节点断裂

- `Availability`（可用性）：发出的请求在规定时间段内总能返回结果（请求响应延迟短，可用性高；否则可用性低）

- 在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。

  可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，

  - 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
  - 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。

> 分布式系统的节点都是在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险。这个网络断开的场景叫做 `网络分区`。

## 2、BASE

BASE 是基本可用（`Basically Available`）、软状态（`Soft State`）和最终一致性（`Eventually Consistent`）三个短语的缩写。

==BASE 理论是对 CAP 中一致性和可用性权衡的结果==，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

###  基本可用

指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。

例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。

### 软状态

指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。

### 最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。

ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。

在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。

# HDFS

## 优缺点

优点：

- 高容错性，数据会自动保存多个副本，当某一个副本丢失后，默认会自动恢复副本数量；
- 适合处理大数据，【数据规模】和【文件规模】；
- 可以构建在廉价机器上，通过多副本机制，提高可靠性；

缺点：

- 不适合低延迟数据访问；
- 不适用大量小文件，【会占满namenode】【寻址时间会超过读取时间】
- 不支持并发写入，只能追加写入，不能随机修改；

## HDFS的写流程

![image-20210303095250897](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210303095250897.png)

1）客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。

2）NameNode返回是否可以上传。

3）客户端请求第一个 Block上传到哪几个DataNode服务器上。

4）NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。

5）客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。

6）dn1、dn2、dn3逐级应答客户端。

7）客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。

8）当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。

## HDFS读数据流程

![image-20210303095401152](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210303095401152.png)

1）客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。

2）挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。

3）DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。

4）客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。

## 2NN的工作机制，和NN的关系

NN中存储着文件名和该文件存储的DN，因为存储在内存，所以存在掉电丢失数据的风险。为了避免这种情况发生，就需要在磁盘中备份元数据 产生的文件为`FsImage`。但是在存入文件时如果还要去更新磁盘内存，就会导致效率太低，因此又引入了 `edit文件`，这样，一旦NN节点断电，可以通过FsImage和Edits的合并，合成元数据。

而==2NN就是专门用于FsImage和Edits的合并==，防止edit文件过大导致掉电恢复时需要时间过长。

具体工作机制如下：

![image-20210222194041586](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222194041586.png)

## DataNode的工作机制

![image-20210222194546607](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222194546607.png)

1）一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。

2）DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。

3）心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令（如复制块数据到另一台机器，或删除某个数据块）。如果超过10分钟30秒没有收到某个DataNode的心跳，则认为该节点不可用。

4）集群运行中可以安全加入和退出一些机器。

## 数据倾斜简单介绍一下。怎么优化？

## 日志机制

# HBase

## 优缺点

优点：

- HBase 采用稀疏表数据模型，方便查询结构化、半结构化甚至非结构化的数据。【不需要事先确定列和列的数据类型】
- 在宏观逻辑上，HBase管理了多张可以==分布存储==在多个节点上的“大表’，理论上大表中的数据行数是无限的。(随着存储服务器数目增长大表的行数也可以随之增长)
- 支持数据分区：HBase 中的 “大表”按 RowKey 的连续取值范围分成多个 “子表”，不同的子表由不同的服务器管理（ReginServer）
- 支持通过增加服务器进行横向扩展。
- 同一个列族的字段被聚合存储在相同的 HDFS 文件中。因此查询时访问同一个列族中的字段速度很快。
- 高可靠性，底层使用的时HDFS和WAL的使用。
- 可性能
  - LSM结构使得具有很高的写入性能；
  - region切分，主键索引（==HBase 关于每个数据表的 RowKey 列都建立了`分布式索引`==）和缓存机制使得Hbase在海量数据下具备一定的随机读取性能；

缺点：

- 不支持复杂的事务，只支持行级事务，即单行数据的读写都是原子性的；
- 不支持对RowKey以外的列建立索引
- 不支持多表连接查询
- 数据类型单一，value都为byte数组

## 架构

![image-20210222123815447](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222123815447.png)

1）ZK

HBase 通过 Zookeeper 来做 Master 的高可用、RegionServer 的监控、元数据的入口以及 集群配置的维护等工作。

2）HMaster

Master 是所有 `Region Server` 的管理者，其实现类为 `HMaster`，主要作用如下：

- 对于表的操作：create, delete, alter（DML）
- 对于 RegionServer的操作：分配 regions到每个RegionServer，监控每个 RegionServer

3）HRegionServer

Region Server 为Region 的管理者，其实现类为 `HRegionServer` ，主要作用为：

- 对于数据的操作：get、put、delete（DDL）
- 对于Region的操作：分裂和合并Region

4）Region

一个Region对应HBase表的一个子表，当表太大（太小）时会发生分裂（合并）

5）Store

一个Store对应HBase表的一个列族，Store的存储有两种：MemStore和StoreFile。

6）StoreFile

保存实际数据的物理文件，StoreFile以 HFile的形式存储在HDFS上。

每个Store会有一个或多个StoreFile（HFile），数据在每个 StoreFile 中都是有序的。又因为在flush（如全局MemStore达到一定数后）后HFile文件的大小不同，所以还会涉及HFile的合并，在合并文件太大时还会切开。

7）MemStore

写缓存，由于 HFile 中的数据要求是有序的，所以数据是先存储在 MemStore 中，排好序后，等到达刷写时机才会刷写到 HFile，每次刷写都会形成一个新的 HFile。 

8）WAL(HLog)

为了防止掉电后MemStore中的数据丢失，数据会先写在一个叫做 Write-Ahead logfile 的文件 中，然后再写入 MemStore 中。所以在系统出现故障的时候，数据可以通过这个日志文件重 建。

## 写流程

![image-20210222124409332](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222124409332.png)

1. Client先访问ZK确定`hbase:meta`表所在的RegionServer；
2. 访问对应的 RegionServer，获取 `hbase:meta` 表，根据写请求的 `namespace:table/RowKey`，查询出目标数据位于哪个RegionServer中的哪个Region中。并将该 table 的 region 信息以 及 meta 表的位置信息缓存在客户端的 meta cache，方便下次访问。
3. 与目标 Region Server 进行通讯；
4. 将数据追加到 WAL文件，然后将数据写入对应的 MemStore，数据会在 MemStore 进行排序；
5. 向客户端发送 ack；
6. 等达到 MemStore 的刷写时机后，将数据刷写到 HFile。

> MemStore的Flush时机
>
> 1. Memstore级别限制：当某个MemStore的大小达到了上限（hbase.hregion.memstore.flush.size，默认128MB），其所在 region 的所有 memstore 都会刷写。
> 2. Region级别限制：当Region中所有Memstore的大小总和达到了上限（hbase.hregion.memstore.block.multiplier * hbase.hregion.memstore.flush.size，默认 2* 128M = 256M），会触发memstore刷新。
> 3. Region Server级别限制：当一个Region Server中所有Memstore的大小总和达到了上限（hbase.regionserver.global.memstore.upperLimit ＊ hbase_heapsize，默认 40%的JVM内存使用量），会触发部分Memstore刷新。Flush顺序是按照Memstore由大到小执行，先Flush Memstore最大的Region，再执行次大的，直至总体Memstore内存使用量低于阈值（hbase.regionserver.global.memstore.lowerLimit ＊ hbase_heapsize，默认 38%的JVM内存使用量）。
> 4. HLog限制：当一个Region Server中HLog数量达到上限（现无需手动设置，最大为32）时，系统会选取最早的一个 HLog 对应的一个或多个Region进行flush
> 5. HBase定期刷新Memstore：默认周期为1小时，确保Memstore不会长时间没有持久化。为避免所有的MemStore在同一时间都进行flush导致的问题，定期的flush操作有20000左右的随机延时。
> 6. 手动执行flush：用户可以通过shell命令 flush ‘tablename’或者flush ‘region name’分别对一个表或者一个Region进行flush。

## 读流程

![image-20210222164541859](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222164541859.png)

1. Client 先访问 zookeeper，获取 `hbase:meta` 表位于哪个 Region Server；
2. 访问对应的 Region Server，获取 `hbase:meta` 表，根据读请求的 `namespace:table/rowkey`， 查询出目标数据位于哪个 Region Server 中的哪个 Region 中。并将该 table 的 region 信息以 及 meta 表的位置信息缓存在客户端的 meta cache，方便下次访问。 
3. 与目标 Region Server 进行通讯；
4. 分别在 Block Cache（读缓存），MemStore 和 Store File（HFile）中查询目标数据，并将查到的所有数据进行合并。此处所有数据是指同一条数据的不同版本（time stamp）或者不同的类型（Put/Delete）；
5. 将从文件中查询到的数据块（Block，HFile 数据存储单元，默认大小为 64KB）缓存到 Block Cache；
6. 将合并后的最终结果返回给客户端。

## StoreFile Compaction

由于memstore每次刷写都会生成一个新的HFile，且同一个字段的不同版本（timestamp） 和不同类型（Put/Delete）有可能会分布在不同的 HFile 中，因此查询时需要遍历所有的 HFile。

为了减少 HFile 的个数，以及清理掉过期和删除的数据，会进行 `StoreFile Compaction`。

Compaction 分为两种，分别是 `Minor Compaction` 和 `Major Compaction`。

- `Minor Compaction` 会将临近的若干个较小的 HFile 合并成一个较大的 HFile，但==不会清理过期和删除的数据==。 
- `Major Compaction` 会将一个 Store 下的所有的 HFile 合并成一个大 HFile，并且==会清理掉过期 和删除的数据==。

![image-20210222172203959](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210222172203959.png)

> 相关问题：已经删除的数据在什么时候会真正的删除？

## Region的分裂

默认情况下，每个 Table 起初只有一个 Region，随着数据的不断写入，Region 会自动进 行拆分。刚拆分时，两个子 Region 都位于当前的 Region Server，但处于负载均衡的考虑， HMaster 有可能会将某个 Region 转移给其他的 Region Server。

Region Split 时机： 

1. 当1个region中的某个Store下所有StoreFile的总大小超过`hbase.hregion.max.filesize`，该 Region 就会进行拆分（0.94 版本之前）。 
2. 当 1 个 region 中 的 某 个 Store 下所有 StoreFile 的总大小超过 `Min(R^2 * "hbase.hregion.memstore.flush.size",hbase.hregion.max.filesize")`，该 Region 就会进行拆分，其 中 R 为当前 Region Server 中属于该 Table 的Region个数（0.94 版本之后）。

# MapReduce

## 优缺点

**优点：**

- 易于编程，只需要实现一些接口，就可以完成一个分布式程序；
- 良好的扩展性，通过增加机器，就可以提升计算能力；
- 高容错性，一台机器的任务执行失败，会自动转移到另一个节点上运行；
- 适合海量数据的离线处理；

**缺点：**

- 不能实时计算，不能像MySQL一样，在毫秒或秒级内返回结果；
- 不能流式计算，它的输入数据都是静态的；

## Hadoop 任务的 Yarn 调度过程

## Yarn 细节，NodeManage 挂掉怎么办，两个任务同时请求资源怎么办

## shuffle机制

![image-20210313220847808](https://gitee.com/yanjundong97/picBed/raw/master/images/image-20210313220847808.png)



### Map Shuffle

Map的输出结果是由`collector`处理的，每个Map任务不断地==将键值对输出到在内存中的一个环形缓冲区中==。使用环形数据结构是为了更有效地使用内存空间，在内存中放置尽可能多的数据。

## shuffle为什么要环形缓冲区

## MapReduce，Reduce 如何获取 Map 的结果





















































